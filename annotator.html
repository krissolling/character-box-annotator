<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Character Box Annotator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f5f5f5;
            padding: 0;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 15px;
        }

        header {
            background: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            color: #333;
            font-size: 20px;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #666;
            font-size: 14px;
        }

        .back-link {
            color: #4CAF50;
            text-decoration: none;
            font-size: 14px;
            display: none;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .back-link.active {
            display: inline-block;
        }

        .setup-panel {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }

        .upload-zone {
            border: 3px dashed #ddd;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #fafafa;
            margin-bottom: 15px;
        }

        .upload-zone:hover {
            border-color: #4CAF50;
            background: #f0f9f0;
        }

        .upload-zone.dragover {
            border-color: #4CAF50;
            background: #e8f5e9;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .upload-text {
            color: #666;
            font-size: 14px;
        }

        .text-input-group {
            margin-bottom: 15px;
        }

        .text-input-group label {
            display: block;
            font-size: 14px;
            color: #333;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .text-input-group input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            transition: border-color 0.2s;
        }

        .text-input-group input:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .start-btn {
            padding: 12px 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            width: 100%;
            transition: background 0.2s;
        }

        .start-btn:hover:not(:disabled) {
            background: #45a049;
        }

        .start-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .main-content {
            display: none;
            flex-direction: column;
            gap: 15px;
        }

        .main-content.active {
            display: flex;
        }

        .canvas-panel {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 15px;
            height: calc(100vh - 30px);
        }

        .resizable-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .resize-handle {
            height: 8px;
            background: #ddd;
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            flex-shrink: 0;
        }

        .resize-handle:hover {
            background: #bbb;
        }

        .resize-handle::after {
            content: '';
            width: 40px;
            height: 3px;
            background: #999;
            border-radius: 2px;
        }

        .canvas-panel > div {
            min-width: 0;
        }

        .middle-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 350px;
        }

        .right-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 0;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
            overflow-y: auto;
        }

        .info-panel, .controls-panel {
            background: white;
            padding: 15px;
            border-radius: 12px;
            border: 2px solid #ddd;
        }

        .panel-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
        }

        .current-char {
            background: #4CAF50;
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .instruction {
            background: #f9f9f9;
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
            color: #666;
            margin-bottom: 10px;
        }

        .progress {
            margin-bottom: 20px;
        }

        .progress-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }

        .progress-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }

        #canvas {
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: crosshair;
            display: block;
        }

        .button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .button-primary {
            background: #4CAF50;
            color: white;
        }

        .button-primary:hover {
            background: #45a049;
        }

        .button-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .button-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .button-secondary:hover {
            background: #e0e0e0;
        }

        .button-secondary:disabled {
            background: #f5f5f5;
            color: #999;
            cursor: not-allowed;
        }

        .button-danger {
            background: #f44336;
            color: white;
        }

        .button-danger:hover {
            background: #da190b;
        }

        .box-list {
            max-height: 300px;
            overflow-y: auto;
            font-size: 12px;
        }

        .box-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #f0f0f0;
        }

        .box-char {
            font-weight: 600;
            font-size: 16px;
        }

        .box-coords {
            color: #666;
            font-size: 11px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-width: 0;
            border-radius: 8px;
            overflow: auto;
        }

        .canvas-wrapper {
            min-width: 100%;
            min-height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            padding: 100px;
        }

        /* Hide scrollbars for canvas-container */
        .canvas-container::-webkit-scrollbar {
            display: none;
        }

        .preview-controls {
            background: white;
            padding: 15px;
            border-radius: 12px;
            border: 2px solid #ddd;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            gap: 10px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-label {
            font-size: 12px;
            color: #666;
            min-width: 80px;
        }

        .control-slider {
            flex: 1;
            height: 6px;
        }

        .control-value {
            font-size: 12px;
            color: #333;
            min-width: 40px;
            text-align: right;
            font-weight: 500;
        }

        input[type="checkbox"] {
            cursor: pointer;
        }

        .char-picker {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 15px;
        }

        .char-picker-btn {
            width: 40px;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            background: #f0f0f0;
            color: #999;
        }

        .char-picker-btn.annotated {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
okay
        .char-picker-btn.current {
            border-color: #2196F3;
            border-width: 3px;
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.3);
        }

        .reset-btn {
            margin-top: 15px;
            background: #FF9800;
        }

        .reset-btn:hover {
            background: #F57C00;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
        }

        .modal-content {
            position: relative;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            z-index: 1001;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 32px;
            line-height: 1;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .modal-close-btn:hover {
            background: #f0f0f0;
            color: #333;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
        }

        /* Spinner animation for auto-solve loading */
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
    </style>
    <script src="https://unpkg.com/feather-icons"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
</head>
<body>
    <div class="container">

        <!-- Setup Panel -->
        <div id="setupPanel" class="setup-panel">
            <div class="upload-zone" id="uploadZone">
                <input type="file" id="fileInput" accept="image/*" style="display: none;">
                <div class="upload-icon">ðŸ“·</div>
                <div class="upload-text">
                    <strong>Drop image here or click to browse</strong><br>
                    <span style="font-size: 12px;">Supports: JPG, PNG, WEBP, GIF</span>
                </div>
            </div>

            <button class="button button-secondary reset-btn" id="resetBtn" style="display: none;">
                â†» Start Over (New Image)
            </button>
        </div>

        <!-- Main Annotation Interface -->
        <div id="mainContent" class="main-content">
            <div class="canvas-panel">
                <!-- Left: Resizable Container with Both Canvases -->
                <div class="resizable-container">
                    <!-- Top: Annotation Canvas -->
                    <div id="annotationSection" style="flex: 1; min-height: 200px; display: flex; flex-direction: column; overflow: hidden;">
                        <div style="position: relative; background: white; border: 2px solid #ddd; border-radius: 8px; flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                            <!-- Tool Palette Group (Parent Container) -->
                            <div id="toolPaletteGroup" style="position: absolute; top: 12px; left: 50%; transform: translateX(-50%); display: grid; grid-template-columns: 100px auto 100px; gap: 8px; align-items: start; z-index: 11; pointer-events: none;">
                                <!-- Current Character Box Container (Right aligned in left column) -->
                                <div style="display: flex; justify-content: flex-end;">
                                    <div id="currentCharBoxContainer" style="display: none; background: rgba(255, 255, 255, 0.95); padding: 6px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); pointer-events: auto;">
                                        <div id="currentCharBox" style="width: 60px; height: 100%; background: #E3F2FD; border: 2px solid #2196F3; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 28px; font-weight: 700; color: #1976D2;">
                                            <span id="currentCharDisplay">T</span>
                                        </div>
                                    </div>
                                </div>

                                <!-- Tool Palette (Center column) -->
                                <div id="toolPalette" style="display: flex; flex-direction: column; background: rgba(255, 255, 255, 0.95); padding: 6px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); pointer-events: auto;">
                                <!-- Tool Buttons Row -->
                                <div style="display: flex; gap: 5px;">
                                    <button id="autoSolveBtn" class="tool-button" style="padding: 6px 10px; font-size: 11px; height: 32px; margin: 0; background: #f5f5f5; color: #333; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 6px;" title="Auto-detect character boxes with Tesseract.js">
                                        <i data-feather="zap" style="width: 16px; height: 16px;"></i> Auto-Solve
                                    </button>
                                    <button id="toolBoundingBox" class="tool-button" style="padding: 6px 10px; font-size: 11px; height: 32px; margin: 0; background: #f5f5f5; color: #333; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 6px;" title="Draw Bounding Box">
                                        <i data-feather="square" style="width: 16px; height: 16px;"></i> Box
                                    </button>
                                    <button id="toolBrushBox" class="tool-button" style="padding: 6px 10px; font-size: 11px; height: 32px; margin: 0; background: #f5f5f5; color: #333; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 6px;" title="Paint Bounding Box">
                                        <i data-feather="edit-3" style="width: 16px; height: 16px;"></i> Brush
                                    </button>
                                    <div style="width: 1px; height: 24px; background: #ddd; margin: 0 2px;"></div>
                                    <button id="toolBaseline" class="tool-button" style="padding: 6px 10px; font-size: 11px; height: 32px; margin: 0; background: #f5f5f5; color: #333; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 6px;" title="Draw Horizontal Baseline">
                                        <i data-feather="minus" style="width: 16px; height: 16px;"></i> Baseline
                                    </button>
                                    <button id="toolAngledBaseline" class="tool-button" style="padding: 6px 10px; font-size: 11px; height: 32px; margin: 0; background: #f5f5f5; color: #333; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 6px;" title="Draw Angled Baseline">
                                        <i data-feather="trending-down" style="width: 16px; height: 16px;"></i> Angled
                                    </button>
                                    <button id="toolRotation" class="tool-button" style="padding: 6px 10px; font-size: 11px; height: 32px; margin: 0; background: #f5f5f5; color: #333; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 6px;" title="Fix Rotation">
                                        <i data-feather="rotate-cw" style="width: 16px; height: 16px;"></i> Rotate
                                    </button>
                                </div>

                                <!-- Separator Line (only shown when mode controls are visible) -->
                                <div id="modeSeparator" style="height: 1px; background: #ddd; margin: 6px 0; display: none;"></div>

                                <!-- Mode-Specific Controls Row -->
                                <!-- Box Mode Controls -->
                                <div id="boxModeControls" style="display: none; align-items: center; min-height: 32px;">
                                    <span id="boxModeText" style="font-size: 11px; color: #666; padding-left: 10px;"></span>
                                </div>

                                <!-- Baseline Mode Controls -->
                                <div id="baselineModeControls" style="display: none; align-items: center; min-height: 32px;">
                                    <span style="font-size: 11px; color: #666; padding-left: 10px;">Click and drag to draw a baseline</span>
                                </div>

                                <!-- Rotation Mode Controls -->
                                <div id="rotationModeControls" style="display: none; gap: 8px; align-items: center; justify-content: space-between; min-height: 32px;">
                                    <span style="font-size: 11px; color: #666; padding-left: 10px;">Draw line to set rotation</span>
                                    <div style="display: flex; gap: 8px; align-items: center;">
                                        <span id="rotationDisplay" style="font-size: 11px; color: #333; font-weight: 600; min-width: 35px; background: #f0f0f0; padding: 4px 8px; border-radius: 3px; border: 1px solid #ddd;">0Â°</span>
                                        <button id="resetRotationBtn" class="button button-secondary" style="padding: 6px 10px; font-size: 11px; height: 32px; width: auto; margin: 0; border: 1px solid #ddd; background: #f5f5f5; color: #333; display: flex; align-items: center; gap: 4px; border-radius: 4px; cursor: pointer;">
                                            <i data-feather="refresh-ccw" style="width: 14px; height: 14px;"></i> Reset
                                        </button>
                                    </div>
                                </div>

                                <!-- Brush Mode Controls -->
                                <div id="brushModeControls" style="display: none; gap: 8px; align-items: center; min-height: 32px;">
                                    <!-- Prompt when no string is set -->
                                    <div id="brushModePrompt" style="display: none; padding-left: 10px;">
                                        <span style="font-size: 11px; color: #666;">Write a string to begin:</span>
                                        <button onclick="document.getElementById('writeStringBtn').click()" style="padding: 4px 10px; font-size: 11px; height: 26px; margin-left: 8px; background: #2196F3; color: white; border: none; border-radius: 3px; cursor: pointer; display: inline-flex; align-items: center; gap: 4px;">
                                            <i data-feather="edit-3" style="width: 12px; height: 12px;"></i> Write String
                                        </button>
                                    </div>
                                    <!-- Brush controls when string is set -->
                                    <div id="brushModeSlider" style="display: flex; gap: 6px; align-items: center; flex: 1; padding-left: 10px;">
                                        <span style="font-size: 11px; color: #666;">Paint a bounding box for the letter to the left</span>
                                        <label style="font-size: 11px; color: #666; white-space: nowrap;">Size:</label>
                                        <input id="brushSizeSlider" type="range" min="10" max="100" value="40" style="width: 80px;">
                                        <span id="brushSizeDisplay" style="font-size: 11px; color: #333; font-weight: 600; min-width: 35px; background: #f0f0f0; padding: 4px 8px; border-radius: 3px; border: 1px solid #ddd;">40px</span>
                                    </div>
                                </div>

                                <!-- Auto-Solve Mode Controls -->
                                <div id="autoSolveModeControls" style="display: none; align-items: center; min-height: 32px;">
                                    <span style="font-size: 11px; color: #666; padding-left: 10px;">Draw box(es) around text regions to analyze. Draw multiple for better coverage.</span>
                                </div>

                                <!-- No String Written Controls -->
                                <div id="noStringModeControls" style="display: none; width: 100%; padding: 0 10px;">
                                    <button onclick="document.getElementById('writeStringBtn').click()" class="button button-primary" style="width: 100%; margin: 0; padding: 8px 16px; font-size: 12px; height: 36px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                                        Write a String to Begin
                                    </button>
                                </div>

                                <!-- No Tool Selected Controls -->
                                <div id="noToolModeControls" style="display: none; align-items: center; min-height: 32px;">
                                    <span style="font-size: 11px; color: #666; padding-left: 10px;">Select a tool above to begin annotating</span>
                                </div>

                                <!-- Angled Baseline Mode Controls -->
                                <div id="angledBaselineModeControls" style="display: none; gap: 8px; align-items: center; justify-content: space-between; min-height: 32px;">
                                    <span style="font-size: 11px; color: #666; padding-left: 10px;">Draw line to set angled baseline</span>
                                    <div style="display: flex; gap: 8px; align-items: center;">
                                        <span id="angledBaselineDisplay" style="font-size: 11px; color: #333; font-weight: 600; min-width: 35px; background: #f0f0f0; padding: 4px 8px; border-radius: 3px; border: 1px solid #ddd;">0Â°</span>
                                        <button id="resetAngledBaselineBtn" class="button button-secondary" style="padding: 6px 10px; font-size: 11px; height: 32px; width: auto; margin: 0; border: 1px solid #ddd; background: #f5f5f5; color: #333; display: flex; align-items: center; gap: 4px; border-radius: 4px; cursor: pointer;">
                                            <i data-feather="refresh-ccw" style="width: 14px; height: 14px;"></i> Reset
                                        </button>
                                    </div>
                                </div>
                                </div>

                                <!-- Action Buttons Container (Left aligned in right column) -->
                                <div style="display: flex; justify-content: flex-start;">
                                    <div id="floatingActionButtonsContainer" style="display: none; background: rgba(255, 255, 255, 0.95); padding: 6px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); pointer-events: auto;">
                                        <div id="floatingActionButtons" style="display: flex; flex-direction: column-reverse; gap: 6px; height: 100%;">
                                            <button id="confirmBrushBoxFloating" class="button button-primary" style="padding: 8px; font-size: 11px; flex: 1; width: 32px; margin: 0; background: #4CAF50; border: none; display: flex; align-items: center; justify-content: center; border-radius: 4px; cursor: pointer;" title="Confirm">
                                                <i data-feather="check" style="width: 16px; height: 16px;"></i>
                                            </button>
                                            <button id="cancelBrushBoxFloating" class="button button-secondary" style="padding: 8px; font-size: 11px; flex: 1; width: 32px; margin: 0; border: 1px solid #ddd; background: #f5f5f5; color: #333; display: flex; align-items: center; justify-content: center; border-radius: 4px; cursor: pointer;" title="Cancel">
                                                <i data-feather="x" style="width: 16px; height: 16px;"></i>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <!-- Zoom Controls Overlay -->
                            <div id="zoomControls" style="position: absolute; bottom: 12px; right: 12px; display: flex; gap: 5px; align-items: center; background: rgba(255, 255, 255, 0.95); padding: 6px 10px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 11; pointer-events: auto;">
                                <button id="zoomOutBtn" class="button button-secondary" style="padding: 4px 8px; font-size: 16px; width: auto; margin: 0;">-</button>
                                <span id="zoomDisplay" style="font-size: 12px; color: #666; min-width: 45px; text-align: center;">100%</span>
                                <button id="zoomInBtn" class="button button-secondary" style="padding: 4px 8px; font-size: 16px; width: auto; margin: 0;">+</button>
                                <button id="zoomFitBtn" class="button button-secondary" style="padding: 4px 8px; font-size: 11px; width: auto; margin: 0;">Fit</button>
                                <button id="zoomResetBtn" class="button button-secondary" style="padding: 4px 8px; font-size: 11px; width: auto; margin: 0;">Reset</button>
                            </div>
                            <!-- Scrollable Canvas Container -->
                            <div class="canvas-container" style="scrollbar-width: none; -ms-overflow-style: none; flex: 1;">
                                <div class="canvas-wrapper">
                                    <canvas id="canvas" style="display: block;"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Draggable Resize Handle -->
                    <div class="resize-handle" id="resizeHandle"></div>

                    <!-- Bottom: Word Preview -->
                    <div id="wordPreviewSection" style="flex: 0 0 300px; min-height: 150px; display: flex; flex-direction: column; overflow: hidden;">
                        <div style="background: white; border: 2px solid #ddd; border-radius: 8px; height: 100%; display: flex; flex-direction: column; overflow: hidden;">
                            <!-- Word Preview Section -->
                            <div id="wordPreviewContainer" style="padding: 12px; padding-bottom: 20px; text-align: center; display: flex; align-items: center; justify-content: center; position: relative; min-height: 0; flex: 1; overflow: hidden;">
                                <canvas id="wordPreview" style="image-rendering: crisp-edges; display: block;"></canvas>
                                <button id="previewWriteStringBtn" class="button button-primary" style="display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; font-size: 16px; font-weight: 600;">Write String</button>
                            </div>

                            <!-- Placeholder Indicators with Kerning Markers -->
                            <div id="placeholderCanvasContainer" style="padding: 12px; padding-top: 0; padding-bottom: 13px; text-align: center; flex-shrink: 0; position: relative;">
                                <canvas id="placeholderCanvas" style="max-width: 100%; height: 60px; image-rendering: crisp-edges; border: none; outline: none; display: inline-block;"></canvas>
                                <button id="resetAllKerningBtn" class="button button-secondary" style="position: absolute; bottom: 13px; right: 12px; padding: 6px; font-size: 11px; display: flex; align-items: center; justify-content: center; border-radius: 4px; min-width: unset; width: 28px; height: 28px;" title="Reset all kerning adjustments to default">
                                    <i data-feather="rotate-ccw" style="width: 14px; height: 14px;"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Sidebar Panels -->
                <div class="middle-column">
                    <div class="sidebar">
                        <div class="info-panel">
                            <button id="writeStringBtn" class="button button-primary" style="margin: 0; width: 100%; margin-bottom: 12px;">Write String</button>
                            <div id="stringDisplay" style="display: none; padding: 8px 12px; background: #f5f5f5; border-radius: 4px; margin-bottom: 12px; font-family: monospace; font-size: 14px; font-weight: 600; text-align: center; color: #333; word-break: break-all;"></div>
                            <button id="editStringBtn" class="button button-secondary" style="margin: 0; width: 100%; margin-bottom: 12px; display: none;">Edit String</button>
                            <div id="boxList" style="margin-top: 10px;">
                                <div id="boxListItems" style="overflow-y: auto; font-size: 12px;">
                                    No bounding boxes yet
                                </div>
                            </div>
                        </div>

                        <div class="controls-panel">
                            <div class="panel-title">Baselines</div>
                            <div id="baselineList" style="margin-top: 10px;">
                                <div id="baselineItems" style="overflow-y: auto; font-size: 12px;">
                                    <div style="padding: 10px; text-align: center; color: #999;">No baselines yet</div>
                                </div>
                            </div>
                        </div>

                        <div class="info-panel">
                            <div class="panel-title">Edited Characters</div>
                            <div id="editedCharsList" style="overflow-y: auto; font-size: 12px; padding: 10px; text-align: center; color: #999;">
                                No edited characters yet
                            </div>
                        </div>

                        <!-- Bottom Section: Visual Controls and Download -->
                        <div style="margin-top: auto; display: flex; flex-direction: column; gap: 15px;">
                            <!-- Visual Controls -->
                            <div class="preview-controls">
                                <div style="font-weight: 600; font-size: 13px; margin-bottom: 8px;">Visual Controls</div>
                                <div class="control-row">
                                    <label class="control-label">Invert</label>
                                    <input type="checkbox" id="invertCheck" style="margin-left: auto;">
                                </div>
                                <div class="control-row">
                                    <label class="control-label">Brightness</label>
                                    <input type="range" id="brightnessSlider" class="control-slider" min="0" max="200" value="100">
                                    <span class="control-value" id="brightnessValue">100</span>
                                </div>
                                <div class="control-row">
                                    <label class="control-label">Contrast</label>
                                    <input type="range" id="contrastSlider" class="control-slider" min="0" max="200" value="100">
                                    <span class="control-value" id="contrastValue">100</span>
                                </div>
                                <div class="control-row">
                                    <label class="control-label">Shadows</label>
                                    <input type="range" id="shadowsSlider" class="control-slider" min="-100" max="100" value="0">
                                    <span class="control-value" id="shadowsValue">0</span>
                                </div>
                                <div class="control-row">
                                    <label class="control-label">Highlights</label>
                                    <input type="range" id="highlightsSlider" class="control-slider" min="-100" max="100" value="0">
                                    <span class="control-value" id="highlightsValue">0</span>
                                </div>
                                <div class="control-row">
                                    <label class="control-label">Grayscale</label>
                                    <input type="range" id="grayscaleSlider" class="control-slider" min="0" max="100" value="100">
                                    <span class="control-value" id="grayscaleValue">100%</span>
                                </div>
                                <div style="display: flex; gap: 6px; margin-top: 20px;">
                                    <button id="autoLevelsBtn" class="button button-primary" style="flex: 1; font-size: 14px;">Auto</button>
                                    <button id="resetFiltersBtn" class="button button-secondary" style="flex: 1; font-size: 14px;" disabled>Reset</button>
                                </div>
                            </div>

                            <!-- Layout Controls -->
                            <div class="preview-controls">
                                <div style="font-weight: 600; font-size: 13px; margin-bottom: 8px;">Layout</div>
                                <div class="control-row">
                                    <label class="control-label">Letter Spacing</label>
                                    <input type="range" id="letterSpacingSlider" class="control-slider" min="-50" max="100" value="0">
                                    <span class="control-value" id="letterSpacingValue">0%</span>
                                </div>
                            </div>

                            <button id="downloadBtn" class="button button-primary" disabled style="width: 100%;">Download Word Image</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- String Input Modal -->
    <div id="stringInputModal" class="modal" style="display: none;">
        <div class="modal-overlay"></div>
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <div class="panel-title">Enter String to Annotate</div>
                <button id="closeStringModalBtn" class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 13px;">String:</label>
                    <input type="text" id="stringInput" placeholder="e.g., HELLO WORLD" autocomplete="off" style="width: 100%; padding: 10px; font-size: 14px; border: 2px solid #ddd; border-radius: 6px; box-sizing: border-box;">
                    <div style="margin-top: 5px; font-size: 12px; color: #666;">
                        <span id="stringCharCount">0 characters</span>
                    </div>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button id="cancelStringBtn" class="button button-secondary" style="flex: 1;">Cancel</button>
                    <button id="confirmStringBtn" class="button button-primary" style="flex: 1;" disabled>Confirm</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Individual Character Editor Modal -->
    <div id="characterEditorModal" class="modal" style="display: none;">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <div class="modal-header">
                <div class="panel-title">Individual Character Editor - <strong id="editingCharLabel">-</strong></div>
                <button id="closeCharEditorBtn" class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div style="background: #f5f5f5; padding: 12px; border-radius: 6px; text-align: center; min-height: 300px; max-height: 550px; display: flex; align-items: flex-start; justify-content: center; overflow: auto; position: relative;">
                    <canvas id="individualCharCanvas" style="image-rendering: crisp-edges; cursor: none; border: 1px solid #ddd; display: block; margin: auto;"></canvas>
                </div>
                <div style="margin-top: 15px;">
                    <div class="control-row" style="margin-bottom: 12px;">
                        <label class="control-label" style="font-size: 13px;">Brush Size</label>
                        <input type="range" id="individualBrushSlider" class="control-slider" min="1" max="80" value="40" style="flex: 1;">
                        <span class="control-value" id="individualBrushValue" style="font-size: 13px;">40px</span>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button id="resetCharEditBtn" class="button button-secondary" style="flex: 1;">Reset Character</button>
                        <button id="doneCharEditorBtn" class="button button-primary" style="flex: 1;">Done</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== MODE DETECTION ====================
        // Detect if we're being called from search (with URL params) or standalone
        const urlParams = new URLSearchParams(window.location.search);
        const isFromSearch = urlParams.has('ocr_filename') || urlParams.has('image_filename') || urlParams.has('text');
        let currentMode = isFromSearch ? 'search' : 'standalone';

        // State
        let canvas, ctx;
        let image = new Image();
        let uploadedFile = null;
        let text = '';
        let boxes = [];
        let currentCharIndex = 0;
        let isDrawing = false;
        let startX, startY;
        let mouseCanvasX = 0;
        let mouseCanvasY = 0;
        let scale = 1;

        // Box editing state
        let selectedBox = null;
        let isDragging = false;
        let isResizing = false;
        let resizeCorner = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let boxStartX = 0;
        let boxStartY = 0;
        let boxStartWidth = 0;
        let boxStartHeight = 0;
        const CORNER_SIZE = 8;
        const CORNER_HIT_SIZE = 20; // Larger hit area for easier grabbing

        // Character deduplication
        let uniqueChars = [];
        let charToBox = {};
        let queryPositionToChar = [];
        let editedChars = {}; // Stores edited/masked character canvases

        // Auto-solve region selection
        let isSelectingAutoSolveRegion = false;
        let autoSolveRegions = []; // Array of regions
        let currentAutoSolveRegion = null; // Currently being drawn
        let autoSolveRegionStart = null;

        // Image filter settings
        let imageFilters = {
            invert: false,
            brightness: 100,
            contrast: 100,
            shadows: 0,
            highlights: 0,
            grayscale: 100
        };

        // Check if any filters have been modified from defaults
        function updateResetButtonState() {
            const resetBtn = document.getElementById('resetFiltersBtn');
            if (!resetBtn) return;

            const hasChanges = imageFilters.invert !== false ||
                               imageFilters.brightness !== 100 ||
                               imageFilters.contrast !== 100 ||
                               imageFilters.shadows !== 0 ||
                               imageFilters.highlights !== 0 ||
                               imageFilters.grayscale !== 100;

            resetBtn.disabled = !hasChanges;
        }

        // Padding for character extraction
        let charPadding = 0;

        // Letter spacing
        let letterSpacing = 0;

        // Per-letter-pair kerning adjustments (index -> pixel adjustment)
        let kerningAdjustments = {};

        // Zoom system
        let zoomLevel = 1.0;
        let baseScale = 1.0;
        const MIN_ZOOM = 0.1;
        const MAX_ZOOM = 4.0;
        const ZOOM_STEP = 0.25;

        // Panning state
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let scrollStartX = 0;
        let scrollStartY = 0;

        // Baseline system
        let baselines = [];
        let baselineIdCounter = 0;
        let isBaselineMode = false;
        const baselineColors = ['#FF5252', '#2196F3', '#4CAF50', '#FF9800', '#9C27B0', '#00BCD4'];

        // Temporary baseline preview (while dragging)
        let tempBaselineY = null; // Y position of horizontal baseline being dragged
        let tempAngledBaselinePos = null; // {x, y} position of angled baseline being dragged
        let isDraggingBaseline = false;

        // Tool system
        let currentTool = null; // 'boundingBox', 'baseline', 'rotation', 'angledBaseline', 'brushBox'

        // Rotation system
        let imageRotation = 0; // Current rotation angle in degrees
        let isRotationMode = false; // Drawing rotation line mode
        let rotationLineStart = null; // {x, y} start of rotation line
        let rotationLineEnd = null; // {x, y} end of rotation line (while dragging)

        // Angled baseline system
        let angledBaselineAngle = 0; // Angle in degrees
        let isAngledBaselineMode = false; // Drawing angled baseline line mode
        let angledBaselineStart = null; // {x, y} start of baseline line
        let angledBaselineEnd = null; // {x, y} end of baseline line (while dragging)
        let angledBaselineFinalized = false; // Whether the line has been set (no more dragging)

        // Brush box system
        let isBrushBoxMode = false;
        let brushBoxSize = 40;
        let brushBoxCanvas = null; // Temporary canvas for brush strokes
        let brushBoxCtx = null;
        let isBrushBoxDrawing = false;
        let isAdjustingBrushSize = false; // For shift+drag
        let brushSizeAdjustStartX = 0;
        let brushSizeAdjustPreviewPos = null; // {x, y} position to show size preview circle

        // Edit mode system
        let isEditMode = false;
        let editBrushSize = 40;
        let isErasing = false;
        let lastEraseX = null;
        let lastEraseY = null;
        let currentEditingCharPos = null; // Currently loaded character for editing
        let individualCharCanvas = null; // Canvas for individual character editor
        let individualCharCtx = null;
        let charPositionsInPreview = []; // Track character positions for hit detection
        let mouseX = null; // Track mouse position for brush preview
        let mouseY = null;

        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);

        function init() {
            if (currentMode === 'search') {
                initSearchMode();
            } else {
                initStandaloneMode();
            }
            // Initialize Feather icons
            if (typeof feather !== 'undefined') {
                feather.replace();
            }
            // Initialize reset kerning button visibility (hide by default)
            updateResetKerningButtonVisibility();
        }

        function initStandaloneMode() {
            console.log('ðŸ”§ Initializing Standalone Mode');
            document.getElementById('setupPanel').style.display = 'block';

            setupUploadZone();
            setupTextInput();
            setupStartButton();
            setupResetButton();
        }

        async function initSearchMode() {
            console.log('ðŸ”— Initializing Search Mode');

            // Get parameters from URL (using actual parameter names from search)
            const query = urlParams.get('text');
            const imageFile = urlParams.get('image_filename');
            const ocrFile = urlParams.get('ocr_filename');

            console.log('Search parameters:', { query, imageFile, ocrFile });

            if (!query || !imageFile) {
                alert('Missing required parameters. Switching to standalone mode.');
                currentMode = 'standalone';
                initStandaloneMode();
                return;
            }

            // Set the text to annotate
            text = query;

            // Hide setup panel
            document.getElementById('setupPanel').style.display = 'none';

            // Load the image from API
            const imagePath = `/image/${imageFile}`;
            const img = new Image();
            img.crossOrigin = 'anonymous';

            img.onload = function() {
                image = img;

                // Set as "uploaded file" for compatibility
                uploadedFile = { name: imageFile };

                // Start annotation directly
                startAnnotation();
            };

            img.onerror = function() {
                alert('Failed to load image from search. Switching to standalone mode.');
                currentMode = 'standalone';
                initStandaloneMode();
            };

            img.src = imagePath;
        }

        function setupUploadZone() {
            const uploadZone = document.getElementById('uploadZone');
            const fileInput = document.getElementById('fileInput');

            uploadZone.addEventListener('click', () => fileInput.click());

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) handleFile(file);
            });

            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('dragover');
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('dragover');
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    handleFile(file);
                }
            });
        }

        function handleFile(file) {
            uploadedFile = file;
            const reader = new FileReader();
            reader.onload = (e) => {
                const uploadZone = document.getElementById('uploadZone');
                uploadZone.innerHTML = `
                    <div class="upload-icon">âœ…</div>
                    <div class="upload-text">
                        <strong>${file.name}</strong><br>
                        <span style="font-size: 12px;">Image loaded</span>
                    </div>
                `;
                // Auto-start annotation
                startAnnotation();
            };
            reader.readAsDataURL(file);
        }

        function setupTextInput() {
            // Text input is now handled via modal in the main interface
        }

        function checkStartButton() {
            // Auto-start when image is uploaded
        }

        function setupStartButton() {
            // Auto-start when image is uploaded
        }

        function setupResetButton() {
            document.getElementById('resetBtn').addEventListener('click', resetAll);
        }

        function resetAll() {
            if (currentMode === 'search') {
                // In search mode, go back to search
                window.location.href = '/';
                return;
            }

            // Standalone mode: reset to upload screen
            // Reset all state
            uploadedFile = null;
            text = '';
            boxes = [];
            charToBox = {};
            currentCharIndex = 0;
            uniqueChars = [];
            queryPositionToChar = [];
            baselines = [];
            baselineIdCounter = 0;
            isBaselineMode = false;
            isEditMode = false;
            isRotationMode = false;
            imageRotation = 0;
            rotationLineStart = null;
            rotationLineEnd = null;
            currentEditingCharPos = null;
            charPositionsInPreview = [];

            // Hide edit UI
            document.getElementById('characterEditorModal').style.display = 'none';
            document.getElementById('editCropsSection').style.display = 'none';

            // Reset UI
            document.getElementById('setupPanel').style.display = 'block';
            document.getElementById('mainContent').classList.remove('active');
            document.getElementById('resetBtn').style.display = 'none';

            // Reset upload zone
            document.getElementById('uploadZone').innerHTML = `
                <input type="file" id="fileInput" accept="image/*" style="display: none;">
                <div class="upload-icon">ðŸ“·</div>
                <div class="upload-text">
                    <strong>Drop image here or click to browse</strong><br>
                    <span style="font-size: 12px;">Supports: JPG, PNG, WEBP, GIF</span>
                </div>
            `;

            // Re-setup
            setupUploadZone();
        }

        function startAnnotation() {
            // Build unique characters
            buildUniqueChars();

            // Hide setup, show main content
            document.getElementById('setupPanel').style.display = 'none';
            document.getElementById('mainContent').classList.add('active');
            document.getElementById('resetBtn').style.display = 'block';

            // If text is already set (from URL), show Edit String button instead of Write String
            if (text && text.length > 0) {
                document.getElementById('writeStringBtn').style.display = 'none';
                document.getElementById('editStringBtn').style.display = 'block';
            }

            // Initialize canvas
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            // Build character picker
            buildCharacterPicker();

            // Setup canvas after image is ready
            const setupCanvas = function() {
                // Set baseScale to 1 (original size)
                baseScale = 1.0;

                // Initial setup at 100% zoom with HiDPI support
                scale = baseScale * zoomLevel;
                const dpr = window.devicePixelRatio || 1;
                const logicalWidth = image.width * scale;
                const logicalHeight = image.height * scale;

                canvas.width = logicalWidth * dpr;
                canvas.height = logicalHeight * dpr;

                canvas.style.width = logicalWidth + 'px';
                canvas.style.height = logicalHeight + 'px';

                ctx.scale(dpr, dpr);

                updateCanvasContainerLayout();
                redraw();
                updateUI();
                updateWordPreview();
                updateZoomUI();

                // Apply fit zoom as default after a brief delay to ensure layout is ready
                setTimeout(() => {
                    fitZoom();
                }, 100);
            };

            // Load image based on mode
            if (currentMode === 'search') {
                // Image is already loaded in initSearchMode
                setupCanvas();
            } else {
                // Standalone mode: load image from file
                const reader = new FileReader();
                reader.onload = (e) => {
                    image.onload = setupCanvas;
                    image.src = e.target.result;
                };
                reader.readAsDataURL(uploadedFile);
            }

            // Setup event listeners
            setupCanvasListeners();
            setupControlListeners();
            setupPreviewCanvasListeners();
            setupIndividualEditorListeners();

            // Get individual editor canvas
            individualCharCanvas = document.getElementById('individualCharCanvas');
            individualCharCtx = individualCharCanvas.getContext('2d');
        }

        function setupCanvasListeners() {
            const canvasContainer = document.querySelector('.canvas-container');

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyDown);

            // Mouse wheel zoom - always zoom from center of viewport
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();

                const containerRect = canvasContainer.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();

                // Find the center of the viewport
                const viewportCenterX = containerRect.left + containerRect.width / 2;
                const viewportCenterY = containerRect.top + containerRect.height / 2;

                // Find where that point is on the canvas (in canvas pixel coordinates)
                const canvasX = viewportCenterX - canvasRect.left;
                const canvasY = viewportCenterY - canvasRect.top;

                // Convert to image coordinates (independent of current zoom)
                const imageX = canvasX / scale;
                const imageY = canvasY / scale;

                // Store old scale
                const oldScale = scale;

                // Zoom (this updates scale and canvas size)
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }

                // Calculate where that image point should be on the NEW canvas
                const newCanvasX = imageX * scale;
                const newCanvasY = imageY * scale;

                // Calculate scroll position so that point is at viewport center
                const newScrollX = newCanvasX - containerRect.width / 2;
                const newScrollY = newCanvasY - containerRect.height / 2;

                canvasContainer.scrollLeft = newScrollX;
                canvasContainer.scrollTop = newScrollY;
            }, { passive: false });

            // Middle mouse button panning
            canvasContainer.addEventListener('mousedown', (e) => {
                if (e.button === 1) { // Middle mouse button
                    e.preventDefault();
                    isPanning = true;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    scrollStartX = canvasContainer.scrollLeft;
                    scrollStartY = canvasContainer.scrollTop;
                    canvasContainer.style.cursor = 'grabbing';
                }
            });

            canvasContainer.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    e.preventDefault();
                    const dx = e.clientX - panStartX;
                    const dy = e.clientY - panStartY;
                    canvasContainer.scrollLeft = scrollStartX - dx;
                    canvasContainer.scrollTop = scrollStartY - dy;
                }
            });

            canvasContainer.addEventListener('mouseup', (e) => {
                if (e.button === 1) {
                    isPanning = false;
                    canvasContainer.style.cursor = '';
                }
            });

            canvasContainer.addEventListener('mouseleave', () => {
                if (isPanning) {
                    isPanning = false;
                    canvasContainer.style.cursor = '';
                }
            });

            // Prevent context menu on middle click
            canvasContainer.addEventListener('contextmenu', (e) => {
                if (isPanning) {
                    e.preventDefault();
                }
            });
        }

        function setupControlListeners() {
            document.getElementById('downloadBtn').addEventListener('click', downloadWordImage);

            document.getElementById('invertCheck').addEventListener('change', (e) => {
                imageFilters.invert = e.target.checked;
                updateResetButtonState();
                updateWordPreview();
            });

            document.getElementById('brightnessSlider').addEventListener('input', (e) => {
                imageFilters.brightness = parseInt(e.target.value);
                document.getElementById('brightnessValue').textContent = imageFilters.brightness;
                updateResetButtonState();
                updateWordPreview();
            });

            document.getElementById('contrastSlider').addEventListener('input', (e) => {
                imageFilters.contrast = parseInt(e.target.value);
                document.getElementById('contrastValue').textContent = imageFilters.contrast;
                updateResetButtonState();
                updateWordPreview();
            });

            document.getElementById('shadowsSlider').addEventListener('input', (e) => {
                imageFilters.shadows = parseInt(e.target.value);
                document.getElementById('shadowsValue').textContent = imageFilters.shadows;
                updateResetButtonState();
                updateWordPreview();
            });

            document.getElementById('highlightsSlider').addEventListener('input', (e) => {
                imageFilters.highlights = parseInt(e.target.value);
                document.getElementById('highlightsValue').textContent = imageFilters.highlights;
                updateResetButtonState();
                updateWordPreview();
            });

            document.getElementById('grayscaleSlider').addEventListener('input', (e) => {
                imageFilters.grayscale = parseInt(e.target.value);
                document.getElementById('grayscaleValue').textContent = imageFilters.grayscale + '%';
                updateResetButtonState();
                updateWordPreview();
            });

            document.getElementById('letterSpacingSlider').addEventListener('input', (e) => {
                letterSpacing = parseInt(e.target.value);
                document.getElementById('letterSpacingValue').textContent = letterSpacing + '%';
                updateWordPreview();
            });

            document.getElementById('resetFiltersBtn').addEventListener('click', () => {
                imageFilters.invert = false;
                imageFilters.brightness = 100;
                imageFilters.contrast = 100;
                imageFilters.shadows = 0;
                imageFilters.highlights = 0;
                imageFilters.grayscale = 100;

                document.getElementById('invertCheck').checked = false;
                document.getElementById('brightnessSlider').value = 100;
                document.getElementById('brightnessValue').textContent = '100';
                document.getElementById('contrastSlider').value = 100;
                document.getElementById('contrastValue').textContent = '100';
                document.getElementById('shadowsSlider').value = 0;
                document.getElementById('shadowsValue').textContent = '0';
                document.getElementById('highlightsSlider').value = 0;
                document.getElementById('highlightsValue').textContent = '0';
                document.getElementById('grayscaleSlider').value = 100;
                document.getElementById('grayscaleValue').textContent = '100%';

                updateResetButtonState();
                updateWordPreview();
            });

            document.getElementById('autoLevelsBtn').addEventListener('click', () => {
                autoAdjustLevels();
            });

            // Setup string input modal
            setupStringInputModal();

            // Setup kerning marker dragging
            setupKerningMarkerDragging();

            // Setup reset all kerning button
            document.getElementById('resetAllKerningBtn').addEventListener('click', resetAllKerning);

            // Setup annotation placeholder clicks
            setupAnnotationPlaceholderClick();

            // Setup resize handle
            setupResizeHandle();

            // Setup tool palette
            setupToolPalette();

            document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
            document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
            document.getElementById('zoomFitBtn').addEventListener('click', fitZoom);
            document.getElementById('zoomResetBtn').addEventListener('click', resetZoom);

            // Mode-specific controls
            document.getElementById('resetRotationBtn').addEventListener('click', resetRotation);
            document.getElementById('resetAngledBaselineBtn').addEventListener('click', resetAngledBaseline);
            document.getElementById('brushSizeSlider').addEventListener('input', updateBrushSize);
            document.getElementById('confirmBrushBoxFloating').addEventListener('click', handleFloatingConfirm);
            document.getElementById('cancelBrushBoxFloating').addEventListener('click', handleFloatingCancel);

            // Auto-solve button
            document.getElementById('autoSolveBtn').addEventListener('click', startAutoSolveRegionSelection);
        }

        // Handle floating confirm button - works for both brush and auto-solve
        function handleFloatingConfirm() {
            if (isBrushBoxMode) {
                confirmBrushBox();
            } else if (isSelectingAutoSolveRegion) {
                confirmAutoSolveRegions();
            }
        }

        // Handle floating cancel button - works for both brush and auto-solve
        function handleFloatingCancel() {
            if (isBrushBoxMode) {
                cancelBrushBox();
            } else if (isSelectingAutoSolveRegion) {
                cancelAutoSolveRegions();
            }
        }

        function setupStringInputModal() {
            const modal = document.getElementById('stringInputModal');
            const overlay = modal.querySelector('.modal-overlay');
            const writeBtn = document.getElementById('writeStringBtn');
            const editBtn = document.getElementById('editStringBtn');
            const closeBtn = document.getElementById('closeStringModalBtn');
            const cancelBtn = document.getElementById('cancelStringBtn');
            const confirmBtn = document.getElementById('confirmStringBtn');
            const input = document.getElementById('stringInput');
            const charCount = document.getElementById('stringCharCount');

            // Load last string from localStorage if it exists
            const lastString = localStorage.getItem('lastAnnotationString');
            if (lastString && !text) {
                input.value = lastString;
            }

            function openModal() {
                modal.style.display = 'flex';
                input.value = text || localStorage.getItem('lastAnnotationString') || '';
                updateCharCount();
                input.focus();
            }

            function closeModal() {
                modal.style.display = 'none';
                input.value = '';
            }

            function updateCharCount() {
                const length = input.value.length;
                charCount.textContent = `${length} character${length !== 1 ? 's' : ''}`;
                confirmBtn.disabled = length === 0;
            }

            function confirmString() {
                const newText = input.value.trim();
                if (newText) {
                    text = newText;

                    // Save to localStorage
                    localStorage.setItem('lastAnnotationString', newText);

                    // Show edit button, hide write button
                    writeBtn.style.display = 'none';
                    editBtn.style.display = 'block';

                    // Reset kerning adjustments when string changes
                    kerningAdjustments = {};

                    // Build character system
                    buildUniqueChars();
                    buildCharacterPicker();
                    updateUI();
                    feather.replace(); // Re-render feather icons
                }
                closeModal();
            }

            writeBtn.addEventListener('click', openModal);
            editBtn.addEventListener('click', openModal);
            closeBtn.addEventListener('click', closeModal);
            cancelBtn.addEventListener('click', closeModal);
            overlay.addEventListener('click', closeModal);
            confirmBtn.addEventListener('click', confirmString);

            // Wire up preview write string button
            const previewWriteBtn = document.getElementById('previewWriteStringBtn');
            previewWriteBtn.addEventListener('click', openModal);

            input.addEventListener('input', updateCharCount);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !confirmBtn.disabled) {
                    confirmString();
                }
            });
        }

        function setupPreviewCanvasListeners() {
            const previewCanvas = document.getElementById('wordPreview');

            previewCanvas.addEventListener('click', handlePreviewClick);

            previewCanvas.addEventListener('mousemove', (e) => {
                const rect = e.target.getBoundingClientRect();
                // With HiDPI, use CSS dimensions (logical pixels) directly
                // Character positions are stored in logical coordinates
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const charPos = findCharAtPoint(x, y);
                previewCanvas.style.cursor = charPos ? 'pointer' : 'default';
            });
        }

        function findCharAtPoint(x, y) {
            for (const charPos of charPositionsInPreview) {
                if (x >= charPos.x && x <= charPos.x + charPos.width &&
                    y >= charPos.y && y <= charPos.y + charPos.height) {
                    return charPos;
                }
            }
            return null;
        }

        function handlePreviewClick(e) {
            const rect = e.target.getBoundingClientRect();
            // With HiDPI, use CSS dimensions (logical pixels) directly
            // Character positions are stored in logical coordinates
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const charPos = findCharAtPoint(x, y);

            if (charPos) {
                loadCharacterIntoEditor(charPos);
            }
        }

        function loadCharacterIntoEditor(charPos) {
            currentEditingCharPos = charPos;

            // Create edited canvas if it doesn't exist
            if (!charPos.box.editedCanvas) {
                createEditedCanvas(charPos.box);
            }

            // Show the modal
            document.getElementById('characterEditorModal').style.display = 'flex';
            document.getElementById('editingCharLabel').textContent = `"${charPos.box.char}"`;

            // Calculate scale to fit in modal, never enlarging
            const editCanvas = charPos.box.editedCanvas;

            // Add padding equal to max brush size so brush can paint at edges
            const edgePadding = 50; // Max brush size

            // Available space in modal (accounting for padding and margins)
            const maxDisplayWidth = 760; // 800px modal - padding
            const maxDisplayHeight = 500; // Larger display area

            // Calculate scale that fits the character + padding in available space
            const widthScale = maxDisplayWidth / (editCanvas.width + edgePadding * 2);
            const heightScale = maxDisplayHeight / (editCanvas.height + edgePadding * 2);

            // Use the smaller scale to ensure entire character fits
            // Never zoom in (scale > 1), only scale down or keep at 1:1
            let scaleFactor = Math.min(1.0, widthScale, heightScale);

            // Canvas size includes padding
            individualCharCanvas.width = (editCanvas.width + edgePadding * 2) * scaleFactor;
            individualCharCanvas.height = (editCanvas.height + edgePadding * 2) * scaleFactor;

            // Store padding info for coordinate translation
            individualCharCanvas.edgePadding = edgePadding * scaleFactor;

            // Invalidate cache for new character
            cachedIndividualCanvas = null;

            // Draw the character with red mask overlay
            redrawIndividualCanvas(true);

            // Update word preview to show selection
            updateWordPreview();
        }

        let cachedIndividualCanvas = null; // Cache the red overlay result

        function redrawIndividualCanvas(forceRedraw = false) {
            if (!currentEditingCharPos) return;

            const editCanvas = currentEditingCharPos.box.editedCanvas;
            const padding = individualCharCanvas.edgePadding || 0;
            const contentWidth = individualCharCanvas.width - padding * 2;
            const contentHeight = individualCharCanvas.height - padding * 2;
            const zoomFactor = contentWidth / editCanvas.width;

            // Only recalculate the heavy parts if forced or not cached
            if (forceRedraw || !cachedIndividualCanvas) {
                // Clear canvas
                individualCharCtx.clearRect(0, 0, individualCharCanvas.width, individualCharCanvas.height);

                // Draw checkerboard pattern for padding and transparency
                const checkerSize = 8;
                individualCharCtx.fillStyle = '#e0e0e0';
                individualCharCtx.fillRect(0, 0, individualCharCanvas.width, individualCharCanvas.height);
                individualCharCtx.fillStyle = '#ffffff';
                for (let y = 0; y < individualCharCanvas.height; y += checkerSize) {
                    for (let x = 0; x < individualCharCanvas.width; x += checkerSize) {
                        if ((Math.floor(x / checkerSize) + Math.floor(y / checkerSize)) % 2 === 0) {
                            individualCharCtx.fillRect(x, y, checkerSize, checkerSize);
                        }
                    }
                }

                // Create a temporary canvas to apply filters
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = editCanvas.width;
                tempCanvas.height = editCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');

                // Draw the edit canvas (with transparency)
                tempCtx.drawImage(editCanvas, 0, 0);

                // Apply current filters
                applyImageFilters(tempCanvas, tempCtx);

                // Draw filtered version with zoom, offset by padding (over checkerboard)
                individualCharCtx.imageSmoothingEnabled = false;
                individualCharCtx.drawImage(tempCanvas, 0, 0, editCanvas.width, editCanvas.height,
                                           padding, padding, contentWidth, contentHeight);

                // Cache this result
                cachedIndividualCanvas = document.createElement('canvas');
                cachedIndividualCanvas.width = individualCharCanvas.width;
                cachedIndividualCanvas.height = individualCharCanvas.height;
                cachedIndividualCanvas.getContext('2d').drawImage(individualCharCanvas, 0, 0);
            } else {
                // Use cached version
                individualCharCtx.clearRect(0, 0, individualCharCanvas.width, individualCharCanvas.height);
                individualCharCtx.drawImage(cachedIndividualCanvas, 0, 0);
            }

            // Always draw brush preview cursor (lightweight)
            if (mouseX !== null && mouseY !== null) {
                // mouseX and mouseY are in display space, but we draw in canvas pixel space
                // So they should match since canvas has no CSS sizing - coordinates are already correct
                individualCharCtx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                individualCharCtx.lineWidth = 2;
                individualCharCtx.beginPath();
                individualCharCtx.arc(mouseX, mouseY, editBrushSize / 2, 0, Math.PI * 2);
                individualCharCtx.stroke();
            }
        }

        function setupIndividualEditorListeners() {
            const charCanvas = document.getElementById('individualCharCanvas');
            const modal = document.getElementById('characterEditorModal');
            const overlay = modal.querySelector('.modal-overlay');
            const modalBody = modal.querySelector('.modal-body');

            // Listen on modal body instead of just canvas to capture events outside canvas bounds
            modalBody.addEventListener('mousedown', handleIndividualMouseDown);
            modalBody.addEventListener('mousemove', handleIndividualMouseMove);
            modalBody.addEventListener('mouseup', handleIndividualMouseUp);
            modalBody.addEventListener('mouseleave', handleIndividualMouseLeave);

            // Brush size
            document.getElementById('individualBrushSlider').addEventListener('input', (e) => {
                editBrushSize = parseInt(e.target.value);
                document.getElementById('individualBrushValue').textContent = editBrushSize + 'px';
                redrawIndividualCanvas(false); // Update cursor preview (use cache)
            });

            // Reset character edit
            document.getElementById('resetCharEditBtn').addEventListener('click', () => {
                if (currentEditingCharPos) {
                    delete currentEditingCharPos.box.editedCanvas;
                    createEditedCanvas(currentEditingCharPos.box);
                    loadCharacterIntoEditor(currentEditingCharPos);
                }
            });

            // Close editor buttons
            document.getElementById('closeCharEditorBtn').addEventListener('click', closeIndividualEditor);
            document.getElementById('doneCharEditorBtn').addEventListener('click', closeIndividualEditor);
            overlay.addEventListener('click', closeIndividualEditor);
        }

        function handleIndividualMouseDown(e) {
            if (!currentEditingCharPos) return;

            isErasing = true;

            const charCanvas = document.getElementById('individualCharCanvas');
            const rect = charCanvas.getBoundingClientRect();

            // Convert from client space to canvas space (with padding, no clamping needed)
            const scaleX = charCanvas.width / rect.width;
            const scaleY = charCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            eraseAtPointInIndividual(x, y);

            lastEraseX = x;
            lastEraseY = y;
        }

        function handleIndividualMouseMove(e) {
            const charCanvas = document.getElementById('individualCharCanvas');
            const rect = charCanvas.getBoundingClientRect();

            // Convert from client space to canvas space (with padding, no clamping needed)
            const scaleX = charCanvas.width / rect.width;
            const scaleY = charCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (isErasing && currentEditingCharPos) {
                // Update cursor position
                mouseX = x;
                mouseY = y;

                if (lastEraseX !== null && lastEraseY !== null) {
                    eraseLineBetweenInIndividual(lastEraseX, lastEraseY, x, y);
                } else {
                    eraseAtPointInIndividual(x, y);
                }

                lastEraseX = x;
                lastEraseY = y;
            } else {
                // Update mouse position for cursor preview
                mouseX = x;
                mouseY = y;

                // Just redraw to show cursor (use cache, don't recalculate red overlay)
                redrawIndividualCanvas(false);
            }
        }

        function handleIndividualMouseUp(e) {
            isErasing = false;
            lastEraseX = null;
            lastEraseY = null;
        }

        function handleIndividualMouseLeave(e) {
            isErasing = false;
            lastEraseX = null;
            lastEraseY = null;
            mouseX = null;
            mouseY = null;
            redrawIndividualCanvas(false); // Use cache
        }

        function eraseAtPointInIndividual(x, y) {
            if (!currentEditingCharPos) return;

            const editCanvas = currentEditingCharPos.box.editedCanvas;
            const padding = individualCharCanvas.edgePadding || 0;
            const contentWidth = individualCharCanvas.width - padding * 2;
            const zoomFactor = contentWidth / editCanvas.width;

            // Subtract padding to get content-relative coordinates, then scale to editCanvas space
            const actualX = (x - padding) / zoomFactor;
            const actualY = (y - padding) / zoomFactor;
            const actualBrushSize = editBrushSize / zoomFactor;

            const ctx = editCanvas.getContext('2d');
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0,0,0,1)';

            ctx.beginPath();
            ctx.arc(actualX, actualY, actualBrushSize / 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalCompositeOperation = 'source-over';

            // Force redraw to recalculate red mask
            redrawIndividualCanvas(true);

            // Update word preview live
            updateWordPreview();
        }

        function eraseLineBetweenInIndividual(x1, y1, x2, y2) {
            if (!currentEditingCharPos) return;

            const editCanvas = currentEditingCharPos.box.editedCanvas;
            const padding = individualCharCanvas.edgePadding || 0;
            const contentWidth = individualCharCanvas.width - padding * 2;
            const zoomFactor = contentWidth / editCanvas.width;

            // Subtract padding to get content-relative coordinates, then scale to editCanvas space
            const actualX1 = (x1 - padding) / zoomFactor;
            const actualY1 = (y1 - padding) / zoomFactor;
            const actualX2 = (x2 - padding) / zoomFactor;
            const actualY2 = (y2 - padding) / zoomFactor;
            const actualBrushSize = editBrushSize / zoomFactor;

            const ctx = editCanvas.getContext('2d');
            ctx.globalCompositeOperation = 'destination-out';
            ctx.strokeStyle = 'rgba(0,0,0,1)';
            ctx.lineWidth = actualBrushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(actualX1, actualY1);
            ctx.lineTo(actualX2, actualY2);
            ctx.stroke();

            ctx.globalCompositeOperation = 'source-over';

            // Force redraw to recalculate red mask
            redrawIndividualCanvas(true);

            // Update word preview live
            updateWordPreview();
        }

        function closeIndividualEditor() {
            document.getElementById('characterEditorModal').style.display = 'none';
            currentEditingCharPos = null;
            mouseX = null;
            mouseY = null;
            cachedIndividualCanvas = null; // Clear cache
            updateUI(); // Update all UI including edited characters list
        }

        function createEditedCanvas(box) {
            // Create a canvas from the original crop WITHOUT filters
            // Filters will be applied at render time so they stay current
            const paddedX = Math.max(0, box.x - charPadding);
            const paddedY = Math.max(0, box.y - charPadding);
            const paddedWidth = Math.min(box.width + charPadding * 2, image.width - paddedX);
            const paddedHeight = Math.min(box.height + charPadding * 2, image.height - paddedY);
            const scale = 2;

            const editCanvas = document.createElement('canvas');
            const editCtx = editCanvas.getContext('2d');
            editCanvas.width = paddedWidth * scale;
            editCanvas.height = paddedHeight * scale;

            // Extract crop accounting for rotation
            const cropCanvas = extractRotatedCrop(image, paddedX, paddedY, paddedWidth, paddedHeight, imageRotation);

            // Draw original crop (no filters - they'll be applied at render time)
            editCtx.drawImage(
                cropCanvas,
                0, 0, paddedWidth, paddedHeight,
                0, 0, paddedWidth * scale, paddedHeight * scale
            );

            // Store in box (this will be the transparency mask after editing)
            box.editedCanvas = editCanvas;
        }

        function buildUniqueChars() {
            uniqueChars = [];
            queryPositionToChar = [];
            const seen = new Set();

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                queryPositionToChar.push(char);
                if (!seen.has(char)) {
                    uniqueChars.push(char);
                    seen.add(char);
                }
            }

            console.log('ðŸ”¤ buildUniqueChars:');
            console.log('  text:', text);
            console.log('  uniqueChars:', uniqueChars);
            console.log('  queryPositionToChar:', queryPositionToChar);
        }

        // Store annotation placeholder letter positions for click detection
        let annotationPlaceholderPositions = [];

        function buildCharacterPicker() {
            updateAnnotationPlaceholder();
        }

        function updateCharacterPicker() {
            updateAnnotationPlaceholder();
        }

        function updateAnnotationPlaceholder() {
            const canvas = document.getElementById('annotationPlaceholderCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            // Set canvas size
            const width = 250; // Fixed width for sidebar
            const height = 40;

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            ctx.scale(dpr, dpr);

            // Clear
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);

            annotationPlaceholderPositions = [];

            if (uniqueChars.length === 0) return;

            // Calculate letter spacing
            const letterWidth = width / uniqueChars.length;
            const fontSize = Math.min(24, letterWidth * 0.7);

            console.log('ðŸŽ¨ updateAnnotationPlaceholder - drawing', uniqueChars.length, 'unique characters');

            for (let i = 0; i < uniqueChars.length; i++) {
                const char = uniqueChars[i];
                const x = i * letterWidth;
                const isAnnotated = !!charToBox[char];
                const isCurrent = i === currentCharIndex;

                console.log(`  [${i}] char='${char}' isAnnotated=${isAnnotated} isCurrent=${isCurrent} x=${x}`);

                // Background color
                if (isCurrent) {
                    ctx.fillStyle = '#E3F2FD'; // Light blue for current
                } else {
                    ctx.fillStyle = '#ffffff';
                }
                ctx.fillRect(x, 0, letterWidth, height);

                // Border
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, 0, letterWidth, height);

                // Text color: green if not annotated, gray if annotated
                ctx.fillStyle = isAnnotated ? '#999' : '#4CAF50';
                ctx.font = `bold ${fontSize}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(char, x + letterWidth / 2, height / 2);

                // Current indicator (underline)
                if (isCurrent) {
                    ctx.fillStyle = '#2196F3';
                    ctx.fillRect(x + 2, height - 4, letterWidth - 4, 3);
                }

                // Store position for click detection (only if not annotated)
                annotationPlaceholderPositions.push({
                    index: i,
                    char: char,
                    x: x,
                    width: letterWidth,
                    isAnnotated: isAnnotated
                });
            }
        }

        // Setup click handler for annotation placeholder
        function setupAnnotationPlaceholderClick() {
            const canvas = document.getElementById('annotationPlaceholderCanvas');
            if (!canvas) return;

            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;

                console.log('ðŸ–±ï¸ Annotation placeholder clicked at x:', x);

                for (const pos of annotationPlaceholderPositions) {
                    if (x >= pos.x && x < pos.x + pos.width) {
                        console.log(`  Clicked on char='${pos.char}' index=${pos.index} isAnnotated=${pos.isAnnotated}`);

                        // Only allow clicking if not yet annotated
                        if (!pos.isAnnotated) {
                            console.log(`  âœ… Setting currentCharIndex to ${pos.index}`);
                            currentCharIndex = pos.index;
                            updateUI();
                            updateAnnotationPlaceholder();
                        } else {
                            console.log(`  âŒ Already annotated, ignoring click`);
                        }
                        break;
                    }
                }
            });

            // Update cursor on hover
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;

                let isOverClickable = false;
                for (const pos of annotationPlaceholderPositions) {
                    if (x >= pos.x && x < pos.x + pos.width && !pos.isAnnotated) {
                        isOverClickable = true;
                        break;
                    }
                }

                canvas.style.cursor = isOverClickable ? 'pointer' : 'default';
            });
        }

        function addBaseline(y) {
            const baseline = {
                id: baselineIdCounter++,
                y: y,
                color: baselineColors[baselines.length % baselineColors.length]
            };
            baselines.push(baseline);

            // Re-associate all existing boxes with baselines
            boxes.forEach(box => {
                const baselineInfo = findClosestBaseline(box.y, box.height, box.x, box.width);
                if (baselineInfo) {
                    box.baseline_id = baselineInfo.baseline_id;
                    box.baseline_offset = baselineInfo.baseline_offset;
                }
            });

            updateBaselineList();
            redraw();
            updateWordPreview();
        }

        function removeBaseline(id) {
            baselines = baselines.filter(b => b.id !== id);
            // Remove baseline associations from boxes
            boxes.forEach(box => {
                if (box.baseline_id === id) {
                    delete box.baseline_id;
                    delete box.baseline_offset;
                }
            });
            updateBaselineList();
            redraw();
            updateWordPreview();
        }

        function updateBaselineList() {
            const container = document.getElementById('baselineItems');
            if (baselines.length === 0) {
                container.innerHTML = '<div style="color: #999; font-style: italic; padding: 4px 0;">No baselines drawn yet</div>';
                return;
            }
            container.innerHTML = baselines.map(b => {
                let label;
                if (b.type === 'angled') {
                    label = `Baseline ${b.id} (${b.angle.toFixed(1)}Â°)`;
                } else {
                    label = `Baseline ${b.id} (y=${Math.round(b.y)})`;
                }
                return `
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; padding: 6px 8px; background: #f5f5f5; border-radius: 4px;">
                        <div style="width: 14px; height: 14px; background: ${b.color}; border-radius: 2px; border: 1px solid #ccc;"></div>
                        <span style="flex: 1; font-size: 12px; color: #333;">${label}</span>
                        <button onclick="removeBaseline(${b.id})" style="padding: 2px 8px; font-size: 11px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>
                    </div>
                `;
            }).join('');
        }

        function updateEditedCharsList() {
            const container = document.getElementById('editedCharsList');
            const editedBoxes = boxes.filter(b => b.editedCanvas);

            if (editedBoxes.length === 0) {
                container.innerHTML = '<div style="color: #999; font-style: italic; padding: 4px 0;">No edited characters yet</div>';
                return;
            }

            container.innerHTML = editedBoxes.map((box, index) => `
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; padding: 6px 8px; background: #f5f5f5; border-radius: 4px;">
                    <span style="flex: 1; font-weight: bold; font-size: 13px; color: #333;">"${box.char}"</span>
                    <button onclick="openEditModalForChar('${box.char}')" style="padding: 2px 8px; font-size: 11px; background: #2196F3; color: white; border: none; border-radius: 3px; cursor: pointer;">Edit</button>
                    <button onclick="deleteCharEdit('${box.char}')" style="padding: 2px 8px; font-size: 11px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>
                </div>
            `).join('');
        }

        function deleteCharEdit(char) {
            const box = boxes.find(b => b.char === char);
            if (box && box.editedCanvas) {
                delete box.editedCanvas;
                updateUI();
            }
        }

        function openEditModalForChar(char) {
            const box = boxes.find(b => b.char === char);
            if (box) {
                const charPos = {
                    box: box,
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
                loadCharacterIntoEditor(charPos);
            }
        }

        function findClosestBaseline(boxY, boxHeight, boxX = 0, boxWidth = 0) {
            const boxBottom = boxY + boxHeight;

            let closestBaseline = null;
            let minDistance = Infinity;

            for (const baseline of baselines) {
                if (baseline.type === 'angled') {
                    // For angled baseline, find where it intersects the box
                    // Use the LEFT EDGE of the box as the reference point (consistent with word preview positioning)
                    const angleRad = baseline.angle * (Math.PI / 180);

                    // Calculate Y coordinate of the baseline at the box's left edge
                    const slope = Math.tan(angleRad);
                    const baselineYAtBox = baseline.y + slope * (boxX - baseline.x);

                    // Check if baseline intersects the box vertically
                    if (baselineYAtBox >= boxY && baselineYAtBox <= boxBottom) {
                        return {
                            baseline_id: baseline.id,
                            baseline_offset: baselineYAtBox - boxY
                        };
                    }

                    // Track closest baseline
                    const distance = Math.min(Math.abs(baselineYAtBox - boxY), Math.abs(baselineYAtBox - boxBottom));
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestBaseline = baseline;
                        closestBaseline._offsetAtBox = baselineYAtBox - boxY;
                    }
                } else {
                    // Horizontal baseline
                    // Check if baseline intersects the box
                    if (baseline.y >= boxY && baseline.y <= boxBottom) {
                        return {
                            baseline_id: baseline.id,
                            baseline_offset: baseline.y - boxY
                        };
                    }

                    // Track closest baseline
                    const distance = Math.min(Math.abs(baseline.y - boxY), Math.abs(baseline.y - boxBottom));
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestBaseline = baseline;
                        closestBaseline._offsetAtBox = baseline.y - boxY;
                    }
                }
            }

            // If no overlap but there are baselines, use closest if within reasonable distance
            if (closestBaseline && minDistance < boxHeight * 2) {
                return {
                    baseline_id: closestBaseline.id,
                    baseline_offset: closestBaseline._offsetAtBox
                };
            }

            return null;
        }

        function findNextUnannotatedChar() {
            console.log('ðŸ” findNextUnannotatedChar:');
            console.log('  uniqueChars:', uniqueChars);
            console.log('  charToBox:', charToBox);

            for (let i = 0; i < uniqueChars.length; i++) {
                const char = uniqueChars[i];
                const hasBox = !!charToBox[char];
                console.log(`  [${i}] char='${char}' hasBox=${hasBox}`);

                if (!hasBox) {
                    console.log(`  âž¡ï¸ Returning index ${i} for char '${char}'`);
                    return i;
                }
            }

            console.log('  âœ… All unique characters annotated, returning', uniqueChars.length);
            return uniqueChars.length;
        }

        function findBoxAtPoint(x, y) {
            for (let i = boxes.length - 1; i >= 0; i--) {
                const box = boxes[i];
                if (x >= box.x && x <= box.x + box.width &&
                    y >= box.y && y <= box.y + box.height) {
                    return box;
                }
            }
            return null;
        }

        function getCornerAtPoint(box, x, y) {
            // Use larger hit size in image coordinates for easier grabbing
            const hitSize = CORNER_HIT_SIZE / scale;

            if (Math.abs(x - box.x) < hitSize && Math.abs(y - box.y) < hitSize) return 'tl';
            if (Math.abs(x - (box.x + box.width)) < hitSize && Math.abs(y - box.y) < hitSize) return 'tr';
            if (Math.abs(x - box.x) < hitSize && Math.abs(y - (box.y + box.height)) < hitSize) return 'bl';
            if (Math.abs(x - (box.x + box.width)) < hitSize && Math.abs(y - (box.y + box.height)) < hitSize) return 'br';
            return null;
        }

        function updateCursor(x, y) {
            if (isBaselineMode) {
                canvas.style.cursor = 'crosshair';
                return;
            }

            const box = findBoxAtPoint(x, y);
            if (box) {
                const corner = getCornerAtPoint(box, x, y);
                if (corner) {
                    const cursors = { 'tl': 'nwse-resize', 'tr': 'nesw-resize', 'bl': 'nesw-resize', 'br': 'nwse-resize' };
                    canvas.style.cursor = cursors[corner];
                } else {
                    canvas.style.cursor = 'move';
                }
            } else if (currentCharIndex < uniqueChars.length) {
                canvas.style.cursor = 'crosshair';
            } else {
                canvas.style.cursor = 'default';
            }
        }

        function handleMouseDown(e) {
            // Ignore middle mouse button (used for panning)
            if (e.button === 1) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = (e.clientX - rect.left) / scale;
            const clickY = (e.clientY - rect.top) / scale;

            // Auto-solve region selection mode
            if (isSelectingAutoSolveRegion) {
                autoSolveRegionStart = { x: clickX, y: clickY };
                currentAutoSolveRegion = { x: clickX, y: clickY, width: 0, height: 0 };
                return;
            }

            // Shift+Drag for brush size adjustment
            if (e.shiftKey && isBrushBoxMode) {
                e.preventDefault(); // Prevent text selection
                isAdjustingBrushSize = true;
                brushSizeAdjustStartX = e.clientX;
                brushSizeAdjustPreviewPos = { x: clickX, y: clickY }; // Lock position for preview circle
                redraw(); // Show initial circle at click position
                return;
            }

            if (isRotationMode) {
                // Start drawing rotation line
                rotationLineStart = { x: clickX, y: clickY };
                rotationLineEnd = { x: clickX, y: clickY };
                return;
            }

            if (isAngledBaselineMode) {
                const existingAngledBaseline = baselines.find(b => b.type === 'angled');

                if (existingAngledBaseline) {
                    // Subsequent angled baseline - use click-and-drag
                    tempAngledBaselinePos = { x: clickX, y: clickY };
                    isDraggingBaseline = true;
                    console.log('âŸ‹ Angled baseline mousedown - starting drag mode at', clickX, clickY);
                    redraw();
                } else {
                    // First angled baseline - draw angle line
                    if (!angledBaselineStart) {
                        // First click - start drawing angled baseline line
                        console.log('âŸ‹ Angled baseline mousedown - starting new line at', clickX, clickY);
                        angledBaselineStart = { x: clickX, y: clickY };
                        angledBaselineEnd = { x: clickX, y: clickY };
                        angledBaselineFinalized = false; // Reset finalized flag when starting new line
                    } else {
                        console.log('âŸ‹ Angled baseline mousedown - line already exists, ignoring (let mouseup handle it)');
                    }
                }
                // If angledBaselineStart already exists, let mouseup handle finishing it
                return;
            }

            if (isBrushBoxMode) {
                // Block brush drawing if no string has been written
                if (!text || text.trim() === '' || currentCharIndex >= uniqueChars.length) {
                    return;
                }

                // Start painting with brush
                isBrushBoxDrawing = true;
                // Draw first brush stroke
                brushBoxCtx.fillStyle = 'rgba(76, 175, 80, 0.5)'; // Semi-transparent green
                brushBoxCtx.beginPath();
                brushBoxCtx.arc(clickX, clickY, brushBoxSize / 2, 0, Math.PI * 2);
                brushBoxCtx.fill();
                updateBrushActionButtons();
                redraw();
                return;
            }

            if (isBaselineMode) {
                // Start dragging a baseline preview
                tempBaselineY = clickY;
                isDraggingBaseline = true;
                redraw();
                return;
            }

            const box = findBoxAtPoint(clickX, clickY);
            if (box) {
                selectedBox = box;
                const corner = getCornerAtPoint(box, clickX, clickY);

                if (corner) {
                    isResizing = true;
                    resizeCorner = corner;
                    dragStartX = clickX;
                    dragStartY = clickY;
                    boxStartX = box.x;
                    boxStartY = box.y;
                    boxStartWidth = box.width;
                    boxStartHeight = box.height;
                } else {
                    isDragging = true;
                    dragStartX = clickX;
                    dragStartY = clickY;
                    boxStartX = box.x;
                    boxStartY = box.y;
                }
                return;
            }

            // Only allow box drawing if boundingBox tool is active
            if (currentTool !== 'boundingBox') return;

            if (currentCharIndex >= uniqueChars.length) return;

            selectedBox = null;
            startX = clickX;
            startY = clickY;
            isDrawing = true;
        }

        function handleMouseMove(e) {
            // Don't process if we're panning
            if (isPanning) return;

            const rect = canvas.getBoundingClientRect();
            const currentX = (e.clientX - rect.left) / scale;
            const currentY = (e.clientY - rect.top) / scale;

            // Track mouse position for character preview
            mouseCanvasX = e.clientX - rect.left;
            mouseCanvasY = e.clientY - rect.top;

            // Auto-solve region selection - update region as user drags
            if (isSelectingAutoSolveRegion && autoSolveRegionStart) {
                const x = Math.min(autoSolveRegionStart.x, currentX);
                const y = Math.min(autoSolveRegionStart.y, currentY);
                const width = Math.abs(currentX - autoSolveRegionStart.x);
                const height = Math.abs(currentY - autoSolveRegionStart.y);
                currentAutoSolveRegion = { x, y, width, height };
                redraw();
                return;
            }

            // Handle brush size adjustment via Shift+Drag
            if (isAdjustingBrushSize) {
                const deltaX = e.clientX - brushSizeAdjustStartX;
                const newSize = Math.max(10, Math.min(100, brushBoxSize + Math.round(deltaX / 2.5))); // 2x sensitivity (was /5)
                if (newSize !== brushBoxSize) {
                    brushBoxSize = newSize;
                    document.getElementById('brushSizeSlider').value = brushBoxSize;
                    document.getElementById('brushSizeDisplay').textContent = brushBoxSize + 'px';
                    brushSizeAdjustStartX = e.clientX; // Update start position for continuous adjustment
                    redraw(); // Show brush size change immediately
                }
                return;
            }

            // Update rotation line endpoint while dragging
            if (isRotationMode && rotationLineStart) {
                rotationLineEnd = { x: currentX, y: currentY };
                redraw();
                return;
            }

            // Update angled baseline line endpoint while dragging (only if not finalized)
            if (isAngledBaselineMode && angledBaselineStart && !angledBaselineFinalized) {
                // Check if there's already an angled baseline - if so, constrain to that angle
                const existingAngledBaseline = baselines.find(b => b.type === 'angled');

                if (existingAngledBaseline) {
                    // Lock to the existing angle
                    const angleRad = existingAngledBaseline.angle * (Math.PI / 180);
                    const dx = currentX - angledBaselineStart.x;
                    const dy = currentY - angledBaselineStart.y;

                    // Project the current position onto the locked angle line
                    // Distance along the angle line
                    const distance = dx * Math.cos(angleRad) + dy * Math.sin(angleRad);

                    // Calculate the constrained end point
                    angledBaselineEnd = {
                        x: angledBaselineStart.x + distance * Math.cos(angleRad),
                        y: angledBaselineStart.y + distance * Math.sin(angleRad)
                    };
                } else {
                    // Free angle drawing for the first baseline
                    angledBaselineEnd = { x: currentX, y: currentY };
                }

                // console.log('âŸ‹ Angled baseline mousemove - updating end to', currentX, currentY);
                redraw();
                return;
            }

            // Paint with brush while dragging
            if (isBrushBoxMode && isBrushBoxDrawing) {
                brushBoxCtx.fillStyle = 'rgba(76, 175, 80, 0.5)';
                brushBoxCtx.beginPath();
                brushBoxCtx.arc(currentX, currentY, brushBoxSize / 2, 0, Math.PI * 2);
                brushBoxCtx.fill();
                redraw();
                return;
            }

            // Update baseline preview while dragging
            if (isDraggingBaseline) {
                if (isBaselineMode) {
                    // Update horizontal baseline Y position
                    tempBaselineY = currentY;
                } else if (isAngledBaselineMode && tempAngledBaselinePos) {
                    // Update angled baseline position
                    tempAngledBaselinePos = { x: currentX, y: currentY };
                }
                redraw();
                return;
            }

            if (!isDrawing && !isDragging && !isResizing) {
                updateCursor(currentX, currentY);
                redraw(); // Redraw to update character preview position
            }

            if (isDragging && selectedBox) {
                const dx = currentX - dragStartX;
                const dy = currentY - dragStartY;
                selectedBox.x = Math.max(0, Math.min(image.width - selectedBox.width, boxStartX + dx));
                selectedBox.y = Math.max(0, Math.min(image.height - selectedBox.height, boxStartY + dy));
                redraw();
                updateWordPreview();
                return;
            }

            if (isResizing && selectedBox) {
                const dx = currentX - dragStartX;
                const dy = currentY - dragStartY;

                switch(resizeCorner) {
                    case 'tl':
                        selectedBox.x = Math.max(0, boxStartX + dx);
                        selectedBox.y = Math.max(0, boxStartY + dy);
                        selectedBox.width = boxStartWidth - (selectedBox.x - boxStartX);
                        selectedBox.height = boxStartHeight - (selectedBox.y - boxStartY);
                        break;
                    case 'tr':
                        selectedBox.y = Math.max(0, boxStartY + dy);
                        selectedBox.width = Math.max(5, boxStartWidth + dx);
                        selectedBox.height = boxStartHeight - (selectedBox.y - boxStartY);
                        break;
                    case 'bl':
                        selectedBox.x = Math.max(0, boxStartX + dx);
                        selectedBox.width = boxStartWidth - (selectedBox.x - boxStartX);
                        selectedBox.height = Math.max(5, boxStartHeight + dy);
                        break;
                    case 'br':
                        selectedBox.width = Math.max(5, boxStartWidth + dx);
                        selectedBox.height = Math.max(5, boxStartHeight + dy);
                        break;
                }

                if (selectedBox.x + selectedBox.width > image.width) {
                    selectedBox.width = image.width - selectedBox.x;
                }
                if (selectedBox.y + selectedBox.height > image.height) {
                    selectedBox.height = image.height - selectedBox.y;
                }

                redraw();
                updateWordPreview();
                return;
            }

            if (!isDrawing) return;

            redraw();
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.strokeRect(
                startX * scale,
                startY * scale,
                (currentX - startX) * scale,
                (currentY - startY) * scale
            );
        }

        function handleMouseUp(e) {
            // Ignore middle mouse button (used for panning)
            if (e.button === 1) return;

            // Auto-solve region selection - add region to array
            if (isSelectingAutoSolveRegion && currentAutoSolveRegion && currentAutoSolveRegion.width > 10 && currentAutoSolveRegion.height > 10) {
                // Add this region to the array
                autoSolveRegions.push({ ...currentAutoSolveRegion });
                console.log(`âœ… Region ${autoSolveRegions.length} added:`, currentAutoSolveRegion);

                // Reset for next region
                currentAutoSolveRegion = null;
                autoSolveRegionStart = null;

                // Update UI to show confirm/cancel buttons
                updateAutoSolveControls();

                redraw();
                return;
            }

            // Handle brush size adjustment completion
            if (isAdjustingBrushSize) {
                isAdjustingBrushSize = false;
                brushSizeAdjustPreviewPos = null;
                redraw(); // Clear the preview circle
                return;
            }

            // Handle rotation line completion
            if (isRotationMode && rotationLineStart && rotationLineEnd) {
                const dx = rotationLineEnd.x - rotationLineStart.x;
                const dy = rotationLineEnd.y - rotationLineStart.y;
                const lineLength = Math.sqrt(dx * dx + dy * dy);

                // Only apply rotation if line is long enough (at least 30 pixels)
                if (lineLength > 30) {
                    const rotationAngle = calculateRotationFromLine(
                        rotationLineStart.x,
                        rotationLineStart.y,
                        rotationLineEnd.x,
                        rotationLineEnd.y
                    );
                    applyRotation(rotationAngle);
                }

                // Clear rotation line
                rotationLineStart = null;
                rotationLineEnd = null;
                redraw();
                return;
            }

            // Handle angled baseline line completion
            if (isAngledBaselineMode && angledBaselineStart && angledBaselineEnd && !angledBaselineFinalized) {
                console.log('âŸ‹ Angled baseline mouseup - finalizing line');
                const dx = angledBaselineEnd.x - angledBaselineStart.x;
                const dy = angledBaselineEnd.y - angledBaselineStart.y;
                const lineLength = Math.sqrt(dx * dx + dy * dy);

                // Only finalize if line is long enough (at least 30 pixels)
                if (lineLength > 30) {
                    // Check if there's already an angled baseline - use that angle
                    const existingAngledBaseline = baselines.find(b => b.type === 'angled');

                    if (existingAngledBaseline) {
                        // Use the existing angle
                        angledBaselineAngle = existingAngledBaseline.angle;
                        console.log('âŸ‹ Using existing angle:', angledBaselineAngle.toFixed(1) + 'Â°');
                    } else {
                        // Calculate new angle from the drawn line
                        const angleRad = Math.atan2(dy, dx);
                        angledBaselineAngle = angleRad * (180 / Math.PI);
                        console.log('âŸ‹ New angle set to:', angledBaselineAngle.toFixed(1) + 'Â°');
                    }

                    document.getElementById('angledBaselineDisplay').textContent = angledBaselineAngle.toFixed(1) + 'Â°';

                    // Add to baselines array
                    const baseline = {
                        id: baselineIdCounter++,
                        type: 'angled',
                        angle: angledBaselineAngle,
                        x: angledBaselineStart.x,
                        y: angledBaselineStart.y,
                        color: baselineColors[baselines.length % baselineColors.length]
                    };
                    baselines.push(baseline);

                    // Re-associate all existing boxes with baselines
                    boxes.forEach(box => {
                        const baselineInfo = findClosestBaseline(box.y, box.height, box.x, box.width);
                        if (baselineInfo) {
                            box.baseline_id = baselineInfo.baseline_id;
                            box.baseline_offset = baselineInfo.baseline_offset;
                        }
                    });

                    // Mark as finalized and clear the drawing state
                    angledBaselineFinalized = true;
                    angledBaselineStart = null;
                    angledBaselineEnd = null;

                    updateBaselineList();
                    updateWordPreview();
                    console.log('âŸ‹ Line finalized and added to baselines');
                } else {
                    console.log('âŸ‹ Line too short (', lineLength, 'px), not finalizing');
                }

                redraw();
                return;
            }

            // Handle baseline drag completion
            if (isDraggingBaseline) {
                if (isBaselineMode && tempBaselineY !== null) {
                    // Finalize horizontal baseline
                    addBaseline(tempBaselineY);
                    tempBaselineY = null;
                } else if (isAngledBaselineMode && tempAngledBaselinePos !== null) {
                    // Finalize angled baseline at the dragged position
                    const existingAngledBaseline = baselines.find(b => b.type === 'angled');

                    if (existingAngledBaseline) {
                        // Use the existing angle
                        const baseline = {
                            id: baselineIdCounter++,
                            type: 'angled',
                            angle: existingAngledBaseline.angle,
                            x: tempAngledBaselinePos.x,
                            y: tempAngledBaselinePos.y,
                            color: baselineColors[baselines.length % baselineColors.length]
                        };
                        baselines.push(baseline);

                        // Re-associate all existing boxes with baselines
                        boxes.forEach(box => {
                            const baselineInfo = findClosestBaseline(box.y, box.height, box.x, box.width);
                            if (baselineInfo) {
                                box.baseline_id = baselineInfo.baseline_id;
                                box.baseline_offset = baselineInfo.baseline_offset;
                            }
                        });

                        updateBaselineList();
                        updateWordPreview();
                    }

                    tempAngledBaselinePos = null;
                }

                isDraggingBaseline = false;
                redraw();
                return;
            }

            // Handle brush box painting completion
            if (isBrushBoxMode && isBrushBoxDrawing) {
                isBrushBoxDrawing = false;
                redraw();
                return;
            }

            if (isDragging || isResizing) {
                isDragging = false;
                isResizing = false;
                resizeCorner = null;

                // Update baseline association if box was moved/resized
                if (selectedBox) {
                    const baselineInfo = findClosestBaseline(selectedBox.y, selectedBox.height, selectedBox.x, selectedBox.width);
                    if (baselineInfo) {
                        selectedBox.baseline_id = baselineInfo.baseline_id;
                        selectedBox.baseline_offset = baselineInfo.baseline_offset;
                    } else {
                        delete selectedBox.baseline_id;
                        delete selectedBox.baseline_offset;
                    }
                }

                redraw();
                updateWordPreview();
                return;
            }

            if (!isDrawing) return;
            isDrawing = false;

            const rect = canvas.getBoundingClientRect();
            const endX = (e.clientX - rect.left) / scale;
            const endY = (e.clientY - rect.top) / scale;

            const width = endX - startX;
            const height = endY - startY;

            if (Math.abs(width) < 5 || Math.abs(height) < 5) {
                redraw();
                return;
            }

            const currentChar = uniqueChars[currentCharIndex];
            const box = {
                char: currentChar,
                x: Math.min(startX, endX),
                y: Math.min(startY, endY),
                width: Math.abs(width),
                height: Math.abs(height)
            };

            // Associate with baseline if one exists
            const baselineInfo = findClosestBaseline(box.y, box.height, box.x, box.width);
            if (baselineInfo) {
                box.baseline_id = baselineInfo.baseline_id;
                box.baseline_offset = baselineInfo.baseline_offset;
            }

            const existingBox = charToBox[currentChar];
            if (existingBox) {
                const oldBoxIndex = boxes.findIndex(b => b.char === currentChar);
                if (oldBoxIndex !== -1) {
                    boxes.splice(oldBoxIndex, 1);
                }
            }

            charToBox[currentChar] = box;
            boxes.push(box);

            currentCharIndex = findNextUnannotatedChar();

            redraw();
            updateUI();
            updateWordPreview();
            isAdjustingBrushSize = false;
        }

        function handleKeyDown(e) {
            // Ignore if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            // [ key - decrease brush size
            if (e.key === '[' && isBrushBoxMode) {
                e.preventDefault();
                brushBoxSize = Math.max(10, brushBoxSize - 5);
                document.getElementById('brushSizeSlider').value = brushBoxSize;
                document.getElementById('brushSizeDisplay').textContent = brushBoxSize + 'px';
                redraw(); // Show brush size change immediately
            }

            // ] key - increase brush size
            if (e.key === ']' && isBrushBoxMode) {
                e.preventDefault();
                brushBoxSize = Math.min(100, brushBoxSize + 5);
                document.getElementById('brushSizeSlider').value = brushBoxSize;
                document.getElementById('brushSizeDisplay').textContent = brushBoxSize + 'px';
                redraw(); // Show brush size change immediately
            }

            // Enter key - confirm brush box
            if (e.key === 'Enter' && isBrushBoxMode) {
                e.preventDefault();
                // Check if there's content to confirm
                const buttonsContainer = document.getElementById('floatingActionButtonsContainer');
                if (buttonsContainer && buttonsContainer.style.display !== 'none') {
                    confirmBrushBox();
                }
            }
        }

        function redraw() {
            // Use logical dimensions (CSS size) for drawing
            const logicalWidth = image.width * scale;
            const logicalHeight = image.height * scale;

            ctx.clearRect(0, 0, logicalWidth, logicalHeight);

            // Apply rotation to image only
            ctx.save();
            if (imageRotation !== 0) {
                // Translate to center, rotate, translate back
                ctx.translate(logicalWidth / 2, logicalHeight / 2);
                ctx.rotate(imageRotation * Math.PI / 180);
                ctx.translate(-logicalWidth / 2, -logicalHeight / 2);
            }
            ctx.drawImage(image, 0, 0, logicalWidth, logicalHeight);
            ctx.restore();

            // Draw baselines
            baselines.forEach(baseline => {
                ctx.strokeStyle = baseline.color;
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();

                if (baseline.type === 'angled') {
                    // Draw angled baseline extending to canvas edges
                    const angleRad = baseline.angle * (Math.PI / 180);
                    const slope = Math.tan(angleRad);

                    // Calculate where the line intersects canvas edges
                    // Line equation: y - baseline.y = slope * (x - baseline.x)
                    // Rearranged: y = slope * (x - baseline.x) + baseline.y

                    // Find intersection with left edge (x = 0)
                    const yAtLeft = slope * (0 - baseline.x) + baseline.y;
                    // Find intersection with right edge (x = logicalWidth / scale)
                    const yAtRight = slope * ((logicalWidth / scale) - baseline.x) + baseline.y;

                    // Draw the line from left to right edge
                    ctx.moveTo(0, yAtLeft * scale);
                    ctx.lineTo(logicalWidth, yAtRight * scale);
                    ctx.stroke();
                    ctx.setLineDash([]);  // Reset dash

                    // Draw baseline label at the starting point
                    ctx.fillStyle = baseline.color;
                    ctx.font = 'bold 12px sans-serif';
                    ctx.fillText(`BL ${baseline.id} (${baseline.angle.toFixed(1)}Â°)`, baseline.x * scale + 5, baseline.y * scale - 5);
                } else {
                    // Draw horizontal baseline
                    ctx.moveTo(0, baseline.y * scale);
                    ctx.lineTo(logicalWidth, baseline.y * scale);
                    ctx.stroke();
                    ctx.setLineDash([]);  // Reset dash

                    // Draw baseline label
                    ctx.fillStyle = baseline.color;
                    ctx.font = 'bold 12px sans-serif';
                    ctx.fillText(`BL ${baseline.id}`, 5, baseline.y * scale - 5);
                }
            });

            // Draw temporary baseline preview while dragging
            if (isDraggingBaseline) {
                ctx.strokeStyle = '#FF9800'; // Orange for preview
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();

                if (isBaselineMode && tempBaselineY !== null) {
                    // Draw horizontal baseline preview
                    ctx.moveTo(0, tempBaselineY * scale);
                    ctx.lineTo(logicalWidth, tempBaselineY * scale);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Label
                    ctx.fillStyle = '#FF9800';
                    ctx.font = 'bold 12px sans-serif';
                    ctx.fillText('Preview', 5, tempBaselineY * scale - 5);
                } else if (isAngledBaselineMode && tempAngledBaselinePos !== null) {
                    // Draw angled baseline preview
                    const existingAngledBaseline = baselines.find(b => b.type === 'angled');
                    if (existingAngledBaseline) {
                        const angleRad = existingAngledBaseline.angle * (Math.PI / 180);
                        const slope = Math.tan(angleRad);

                        // Find intersection with left edge (x = 0)
                        const yAtLeft = slope * (0 - tempAngledBaselinePos.x) + tempAngledBaselinePos.y;
                        // Find intersection with right edge
                        const yAtRight = slope * ((logicalWidth / scale) - tempAngledBaselinePos.x) + tempAngledBaselinePos.y;

                        // Draw the line from left to right edge
                        ctx.moveTo(0, yAtLeft * scale);
                        ctx.lineTo(logicalWidth, yAtRight * scale);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Label
                        ctx.fillStyle = '#FF9800';
                        ctx.font = 'bold 12px sans-serif';
                        ctx.fillText(`Preview (${existingAngledBaseline.angle.toFixed(1)}Â°)`, tempAngledBaselinePos.x * scale + 5, tempAngledBaselinePos.y * scale - 5);
                    }
                }
            }

            boxes.forEach((box) => {
                const isSelected = (box === selectedBox);

                if (isSelected) {
                    ctx.strokeStyle = '#2196F3';
                    ctx.lineWidth = 3;
                } else {
                    ctx.strokeStyle = box === boxes[boxes.length - 1] ? '#4CAF50' : '#81C784';
                    ctx.lineWidth = 2;
                }

                ctx.strokeRect(
                    box.x * scale,
                    box.y * scale,
                    box.width * scale,
                    box.height * scale
                );

                // Scale label size relative to box height - make it taller (30% of box height, min 18px, max 32px)
                const labelHeight = Math.max(18, Math.min(32, box.height * scale * 0.3));
                const labelWidth = labelHeight * 1.5;
                const fontSize = Math.max(12, Math.min(20, box.height * scale * 0.2));
                const labelOffset = 4; // Gap between box and label
                const borderRadius = 4; // Rounded corners

                // Draw rounded rectangle background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                const labelX = box.x * scale;
                const labelY = box.y * scale - labelHeight - labelOffset;

                ctx.beginPath();
                ctx.moveTo(labelX + borderRadius, labelY);
                ctx.lineTo(labelX + labelWidth - borderRadius, labelY);
                ctx.quadraticCurveTo(labelX + labelWidth, labelY, labelX + labelWidth, labelY + borderRadius);
                ctx.lineTo(labelX + labelWidth, labelY + labelHeight - borderRadius);
                ctx.quadraticCurveTo(labelX + labelWidth, labelY + labelHeight, labelX + labelWidth - borderRadius, labelY + labelHeight);
                ctx.lineTo(labelX + borderRadius, labelY + labelHeight);
                ctx.quadraticCurveTo(labelX, labelY + labelHeight, labelX, labelY + labelHeight - borderRadius);
                ctx.lineTo(labelX, labelY + borderRadius);
                ctx.quadraticCurveTo(labelX, labelY, labelX + borderRadius, labelY);
                ctx.closePath();
                ctx.fill();

                // Draw text centered vertically and horizontally
                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(box.char, labelX + labelWidth / 2, labelY + labelHeight / 2);

                // Reset text align for other drawing operations
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';

                if (isSelected) {
                    ctx.fillStyle = '#2196F3';
                    const corners = [
                        [box.x, box.y],
                        [box.x + box.width, box.y],
                        [box.x, box.y + box.height],
                        [box.x + box.width, box.y + box.height]
                    ];
                    corners.forEach(([cx, cy]) => {
                        ctx.fillRect(
                            cx * scale - CORNER_SIZE / 2,
                            cy * scale - CORNER_SIZE / 2,
                            CORNER_SIZE,
                            CORNER_SIZE
                        );
                    });
                }
            });

            // Draw rotation line while dragging
            if (isRotationMode && rotationLineStart && rotationLineEnd) {
                ctx.strokeStyle = '#FF9800';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(rotationLineStart.x * scale, rotationLineStart.y * scale);
                ctx.lineTo(rotationLineEnd.x * scale, rotationLineEnd.y * scale);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw endpoints
                ctx.fillStyle = '#FF9800';
                ctx.beginPath();
                ctx.arc(rotationLineStart.x * scale, rotationLineStart.y * scale, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(rotationLineEnd.x * scale, rotationLineEnd.y * scale, 5, 0, Math.PI * 2);
                ctx.fill();

                // Calculate and display angle hint
                const dx = rotationLineEnd.x - rotationLineStart.x;
                const dy = rotationLineEnd.y - rotationLineStart.y;
                const lineLength = Math.sqrt(dx * dx + dy * dy);

                if (lineLength > 30) {
                    const angle = calculateRotationFromLine(
                        rotationLineStart.x,
                        rotationLineStart.y,
                        rotationLineEnd.x,
                        rotationLineEnd.y
                    );

                    // Show hint text
                    const midX = (rotationLineStart.x + rotationLineEnd.x) / 2 * scale;
                    const midY = (rotationLineStart.y + rotationLineEnd.y) / 2 * scale;

                    ctx.fillStyle = 'rgba(255, 152, 0, 0.9)';
                    ctx.fillRect(midX - 40, midY - 20, 80, 30);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${angle.toFixed(1)}Â°`, midX, midY);
                }
            }

            // Draw angled baseline line while dragging
            if (isAngledBaselineMode && angledBaselineStart && angledBaselineEnd) {
                ctx.strokeStyle = '#9C27B0';  // Purple
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(angledBaselineStart.x * scale, angledBaselineStart.y * scale);
                ctx.lineTo(angledBaselineEnd.x * scale, angledBaselineEnd.y * scale);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw endpoints
                ctx.fillStyle = '#9C27B0';
                ctx.beginPath();
                ctx.arc(angledBaselineStart.x * scale, angledBaselineStart.y * scale, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(angledBaselineEnd.x * scale, angledBaselineEnd.y * scale, 5, 0, Math.PI * 2);
                ctx.fill();

                // Show angle hint
                const dx = angledBaselineEnd.x - angledBaselineStart.x;
                const dy = angledBaselineEnd.y - angledBaselineStart.y;
                const lineLength = Math.sqrt(dx * dx + dy * dy);

                if (lineLength > 30) {
                    const angleRad = Math.atan2(dy, dx);
                    const angleDeg = angleRad * (180 / Math.PI);

                    const midX = (angledBaselineStart.x + angledBaselineEnd.x) / 2 * scale;
                    const midY = (angledBaselineStart.y + angledBaselineEnd.y) / 2 * scale;

                    ctx.fillStyle = 'rgba(156, 39, 176, 0.9)';
                    ctx.fillRect(midX - 40, midY - 20, 80, 30);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${angleDeg.toFixed(1)}Â°`, midX, midY);
                }
            }

            // Draw auto-solve region selection boxes
            if (isSelectingAutoSolveRegion) {
                // Draw all saved regions
                autoSolveRegions.forEach((region, index) => {
                    ctx.strokeStyle = '#4CAF50';  // Green
                    ctx.fillStyle = 'rgba(76, 175, 80, 0.15)';  // Light green fill
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    ctx.strokeRect(
                        region.x * scale,
                        region.y * scale,
                        region.width * scale,
                        region.height * scale
                    );
                    ctx.fillRect(
                        region.x * scale,
                        region.y * scale,
                        region.width * scale,
                        region.height * scale
                    );

                    // Draw region number
                    ctx.fillStyle = '#4CAF50';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    ctx.fillText(
                        `Region ${index + 1}`,
                        region.x * scale + 5,
                        region.y * scale + 5
                    );
                });

                // Draw currently being drawn region
                if (currentAutoSolveRegion && currentAutoSolveRegion.width > 0 && currentAutoSolveRegion.height > 0) {
                    ctx.strokeStyle = '#FF9800';  // Orange for current
                    ctx.fillStyle = 'rgba(255, 152, 0, 0.1)';  // Light orange fill
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 5]);
                    ctx.strokeRect(
                        currentAutoSolveRegion.x * scale,
                        currentAutoSolveRegion.y * scale,
                        currentAutoSolveRegion.width * scale,
                        currentAutoSolveRegion.height * scale
                    );
                    ctx.fillRect(
                        currentAutoSolveRegion.x * scale,
                        currentAutoSolveRegion.y * scale,
                        currentAutoSolveRegion.width * scale,
                        currentAutoSolveRegion.height * scale
                    );
                    ctx.setLineDash([]);

                    // Draw label
                    ctx.fillStyle = '#FF9800';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    ctx.fillText(
                        'Drawing...',
                        currentAutoSolveRegion.x * scale + 5,
                        currentAutoSolveRegion.y * scale + 5
                    );
                }
            }

            // Draw brush box strokes overlay
            if (isBrushBoxMode && brushBoxCanvas) {
                ctx.globalAlpha = 0.6;
                ctx.drawImage(brushBoxCanvas, 0, 0, logicalWidth, logicalHeight);
                ctx.globalAlpha = 1.0;

                // Draw brush cursor preview
                // Use locked position when adjusting size, otherwise use mouse position
                const previewPos = isAdjustingBrushSize && brushSizeAdjustPreviewPos
                    ? brushSizeAdjustPreviewPos
                    : null;

                if (previewPos) {
                    // Draw at locked position during size adjustment
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(previewPos.x * scale, previewPos.y * scale, (brushBoxSize / 2) * scale, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (mouseCanvasX > 0 && mouseCanvasY > 0 && !isBrushBoxDrawing) {
                    // Draw at mouse position normally
                    // mouseCanvasX/Y are already in canvas pixel coordinates
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(mouseCanvasX, mouseCanvasY, (brushBoxSize / 2) * scale, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        function updateUI() {
            updateBoxList();
            updateCharacterPicker();
            updateEditedCharsList();
            updateWordPreview();
            updateBoxModeText();
            updateBrushModeControls();
            updateAnnotationToolsState();
            updateNoStringModeControls();
            updateNoToolModeControls();
        }

        function updateAnnotationToolsState() {
            const hasString = text && text.length > 0;
            const boxBtn = document.getElementById('toolBoundingBox');
            const brushBtn = document.getElementById('toolBrushBox');
            const autoSolveBtn = document.getElementById('autoSolveBtn');

            // Enable/disable annotation tools based on whether string is set
            [boxBtn, brushBtn, autoSolveBtn].forEach(btn => {
                if (hasString) {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                } else {
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                    btn.style.cursor = 'not-allowed';
                }
            });
        }

        function updateNoStringModeControls() {
            const noStringControls = document.getElementById('noStringModeControls');
            const separator = document.getElementById('modeSeparator');
            const placeholderContainer = document.getElementById('placeholderCanvasContainer');

            // Show "write string" prompt if there's no string written
            const hasString = text && text.length > 0;

            if (!hasString) {
                noStringControls.style.display = 'block';
                separator.style.display = 'block';
                // Hide placeholder canvas and kerning reset button when no string
                if (placeholderContainer) placeholderContainer.style.display = 'none';
            } else {
                noStringControls.style.display = 'none';
                // Show placeholder canvas and kerning reset button when string exists
                if (placeholderContainer) placeholderContainer.style.display = 'block';
            }
        }

        function updateNoToolModeControls() {
            const noToolControls = document.getElementById('noToolModeControls');
            const separator = document.getElementById('modeSeparator');

            // Show "no tool selected" message if:
            // 1. There's a string written
            // 2. No tool is currently active
            // 3. Not in any special mode (auto-solve, rotation, baseline, etc.)
            const hasString = text && text.length > 0;
            const noToolActive = !currentTool && !isSelectingAutoSolveRegion && !isRotationMode && !isAngledBaselineMode && !isBrushBoxMode && !isBaselineMode;

            if (hasString && noToolActive) {
                noToolControls.style.display = 'flex';
                // Only show separator if no other mode controls are visible
                const otherControlsVisible =
                    document.getElementById('boxModeControls').style.display === 'flex' ||
                    document.getElementById('brushModeControls').style.display !== 'none' ||
                    document.getElementById('rotationModeControls').style.display !== 'none' ||
                    document.getElementById('angledBaselineModeControls').style.display !== 'none' ||
                    document.getElementById('baselineModeControls').style.display !== 'none' ||
                    document.getElementById('autoSolveModeControls').style.display !== 'none';

                if (!otherControlsVisible) {
                    separator.style.display = 'block';
                }
            } else {
                noToolControls.style.display = 'none';
            }
        }

        function updateBoxList() {
            const boxListEl = document.getElementById('boxListItems');
            const stringDisplayEl = document.getElementById('stringDisplay');
            if (!boxListEl) return;

            // Update string display
            if (text && stringDisplayEl) {
                stringDisplayEl.textContent = text;
                stringDisplayEl.style.display = 'block';
            } else if (stringDisplayEl) {
                stringDisplayEl.style.display = 'none';
            }

            // If no string set, show placeholder
            if (!text || uniqueChars.length === 0) {
                boxListEl.innerHTML = '<div style="padding: 10px; text-align: center; color: #999;">No string yet</div>';
                return;
            }

            // Show unique characters only (not all positions)
            let html = '';
            uniqueChars.forEach((char, index) => {
                const hasBox = !!charToBox[char];
                const isCurrent = index === currentCharIndex;

                // Green if annotated, grey if not, blue border if current
                const bgColor = isCurrent ? '#E3F2FD' : (hasBox ? '#E8F5E9' : '#f5f5f5');
                const borderColor = isCurrent ? '#2196F3' : (hasBox ? '#4CAF50' : '#ddd');
                const textColor = hasBox ? '#2E7D32' : '#999';

                html += `
                    <div style="
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding: 6px 8px;
                        margin-bottom: 4px;
                        background: ${bgColor};
                        border: 2px solid ${borderColor};
                        border-radius: 4px;
                        cursor: pointer;
                    " onclick="currentCharIndex = ${index}; updateUI(); updateWordPreview();">
                        <span style="font-weight: bold; color: ${textColor}; font-size: 14px;">${char}</span>
                        ${hasBox ? `<button
                            onclick="event.stopPropagation(); deleteCharacterBox('${char}')"
                            style="
                                padding: 2px 8px;
                                font-size: 11px;
                                background: #f44336;
                                color: white;
                                border: none;
                                border-radius: 3px;
                                cursor: pointer;
                            ">Delete</button>` : `<span style="font-size: 11px; color: #999;">Not drawn</span>`}
                    </div>
                `;
            });
            boxListEl.innerHTML = html;
        }

        function deleteBox(index) {
            const box = boxes[index];
            boxes.splice(index, 1);

            // Remove from charToBox mapping
            if (charToBox[box.char] === box) {
                delete charToBox[box.char];
            }

            redraw();
            updateUI();
        }

        function deleteCharacterBox(char) {
            const box = charToBox[char];
            if (!box) return;

            // Find and remove from boxes array
            const index = boxes.indexOf(box);
            if (index !== -1) {
                boxes.splice(index, 1);
            }

            // Remove from charToBox mapping
            delete charToBox[char];

            // Clear kerning adjustments for all positions where this character appears
            // We need to clear kerning for positions before and after this character
            queryPositionToChar.forEach((c, i) => {
                if (c === char) {
                    // Clear kerning before this position (between this and previous char)
                    if (i > 0 && kerningAdjustments[i - 1] !== undefined) {
                        delete kerningAdjustments[i - 1];
                        console.log(`ðŸ—‘ï¸ Cleared kerning at position ${i - 1} (before deleted char '${char}')`);
                    }
                    // Clear kerning after this position (between this and next char)
                    if (kerningAdjustments[i] !== undefined) {
                        delete kerningAdjustments[i];
                        console.log(`ðŸ—‘ï¸ Cleared kerning at position ${i} (after deleted char '${char}')`);
                    }
                }
            });

            redraw();
            updateUI();
            updateWordPreview();
        }

        function skipCharacter() {
            if (currentCharIndex >= uniqueChars.length) return;
            currentCharIndex++;
            updateUI();
        }

        function undoLastBox() {
            if (boxes.length === 0) return;
            const lastBox = boxes.pop();
            delete charToBox[lastBox.char];
            currentCharIndex = findNextUnannotatedChar();
            redraw();
            updateUI();
            updateWordPreview();
        }

        function clearAllBoxes() {
            if (!confirm('Are you sure you want to clear all boxes?')) return;
            boxes = [];
            charToBox = {};
            kerningAdjustments = {};
            currentCharIndex = 0;
            redraw();
            updateUI();
            updateWordPreview();
        }

        function updateWordPreview(skipUIElements = false) {
            const previewCanvas = document.getElementById('wordPreview');
            const previewCtx = previewCanvas.getContext('2d');
            const previewContainer = document.getElementById('wordPreviewContainer');
            let scale = 2;

            // Clear character positions for hit detection
            if (!skipUIElements) {
                charPositionsInPreview = [];
            }

            // Show write string button if no string is set
            const previewWriteBtn = document.getElementById('previewWriteStringBtn');
            if (!text) {
                previewCanvas.width = 0;
                previewCanvas.height = 0;
                previewWriteBtn.style.display = 'block';
                previewCanvas.style.display = 'none';
                document.getElementById('downloadBtn').disabled = true;
                return;
            }

            // Hide button and show canvas when string exists
            previewWriteBtn.style.display = 'none';
            previewCanvas.style.display = 'block';

            let minWidth = Infinity;
            let maxHeight = 0;

            for (const box of boxes) {
                const paddedWidth = Math.min(box.width + charPadding * 2, image.width);
                const paddedHeight = Math.min(box.height + charPadding * 2, image.height);
                minWidth = Math.min(minWidth, paddedWidth);
                maxHeight = Math.max(maxHeight, paddedHeight);
            }

            // Set default dimensions for placeholders when no boxes exist
            if (minWidth === Infinity) minWidth = 50;
            if (maxHeight === 0) maxHeight = 60;

            const charImages = [];
            let totalWidth = 0;

            let avgCharWidth = 0;
            if (boxes.length > 0) {
                avgCharWidth = boxes.reduce((sum, box) => sum + (box.width + charPadding * 2), 0) / boxes.length;
            } else {
                avgCharWidth = minWidth;
            }

            for (let i = 0; i < queryPositionToChar.length; i++) {
                const char = queryPositionToChar[i];
                const box = charToBox[char];

                if (box) {
                    const paddedWidth = Math.min(box.width + charPadding * 2, image.width);
                    const paddedHeight = Math.min(box.height + charPadding * 2, image.height);
                    charImages.push({
                        type: 'real',
                        char: char,
                        box: box,
                        width: paddedWidth,
                        height: paddedHeight
                    });
                    totalWidth += paddedWidth;
                } else {
                    charImages.push({
                        type: 'placeholder',
                        char: char,
                        width: minWidth,
                        height: maxHeight
                    });
                    totalWidth += minWidth;
                }

                if (i < queryPositionToChar.length - 1) {
                    const spacingPixels = (letterSpacing / 100) * avgCharWidth;
                    totalWidth += spacingPixels;
                }
            }

            // Get available container size and adjust scale if needed
            const containerWidth = previewContainer.getBoundingClientRect().width - 24; // minus padding
            const containerHeight = previewContainer.getBoundingClientRect().height - 40; // minus padding (12px top + 20px bottom + some buffer)

            // Calculate scale based on width constraint
            let desiredWidth = totalWidth * scale;
            if (desiredWidth > containerWidth) {
                scale = containerWidth / totalWidth;
            }

            // Also check height constraint and reduce scale further if needed
            let estimatedHeight = maxHeight * scale;
            if (estimatedHeight > containerHeight) {
                scale = Math.min(scale, containerHeight / maxHeight);
            }

            // Calculate unified baseline position for baseline-aligned characters
            let unifiedBaselineY = 0;
            const baselinedBoxes = charImages.filter(item => item.type === 'real' && item.box.baseline_offset !== undefined);
            let canvasHeight = maxHeight * scale;

            // Check if there are any angled baselines
            const angledBaseline = baselines.find(b => b.type === 'angled');
            const hasAngledBaseline = angledBaseline !== undefined;
            const baselineAngle = hasAngledBaseline ? angledBaseline.angle : 0;
            const baselineAngleRad = baselineAngle * (Math.PI / 180);
            const baselineSlope = Math.tan(baselineAngleRad);

            if (baselinedBoxes.length > 0) {
                // Find maximum offset above baseline (ensures no character gets cut off)
                const maxOffsetAbove = Math.max(...baselinedBoxes.map(item => item.box.baseline_offset));
                unifiedBaselineY = maxOffsetAbove * scale;

                // Calculate maximum space needed below baseline
                const maxBelowBaseline = Math.max(...baselinedBoxes.map(item => {
                    const paddedHeight = Math.min(item.box.height + charPadding * 2, image.height);
                    return paddedHeight - item.box.baseline_offset;
                }));

                // Canvas height needs to fit both above and below baseline
                const baselineRequiredHeight = (maxOffsetAbove + maxBelowBaseline) * scale;
                canvasHeight = Math.max(canvasHeight, baselineRequiredHeight);

                // For angled baselines, we need extra height to account for the slope
                if (hasAngledBaseline) {
                    // Calculate total width to estimate the vertical rise
                    const totalWidth = charImages.reduce((sum, item) => {
                        if (item.type === 'real') {
                            const paddedWidth = Math.min(item.box.width + charPadding * 2, image.width);
                            return sum + paddedWidth * scale;
                        }
                        return sum + item.width * scale;
                    }, 0);

                    // Add vertical space for the slope
                    const slopeHeight = Math.abs(totalWidth * baselineSlope);
                    canvasHeight += slopeHeight;

                    // Adjust unified baseline Y if slope is negative (going up)
                    if (baselineSlope < 0) {
                        unifiedBaselineY += slopeHeight;
                    }
                }
            }

            // HiDPI support for word preview
            const dpr = window.devicePixelRatio || 1;

            previewCanvas.width = totalWidth * scale * dpr;
            previewCanvas.height = canvasHeight * dpr;

            // Set CSS size to logical size
            previewCanvas.style.width = (totalWidth * scale) + 'px';
            previewCanvas.style.height = canvasHeight + 'px';

            // Scale context to account for DPR
            previewCtx.scale(dpr, dpr);

            previewCtx.fillStyle = '#ffffff';
            previewCtx.fillRect(0, 0, totalWidth * scale, canvasHeight);

            const spacingPixels = (letterSpacing / 100) * avgCharWidth * scale;

            // Render real characters
            let offsetX = 0;
            for (let i = 0; i < charImages.length; i++) {
                const item = charImages[i];

                if (item.type === 'real') {
                    const paddedX = Math.max(0, item.box.x - charPadding);
                    const paddedY = Math.max(0, item.box.y - charPadding);
                    const paddedWidth = Math.min(item.box.width + charPadding * 2, image.width - paddedX);
                    const paddedHeight = Math.min(item.box.height + charPadding * 2, image.height - paddedY);

                    let tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = paddedWidth * scale;
                    tempCanvas.height = paddedHeight * scale;

                    // Extract crop accounting for rotation
                    const cropCanvas = extractRotatedCrop(image, paddedX, paddedY, paddedWidth, paddedHeight, imageRotation);

                    // Draw the extracted crop onto temp canvas at scale
                    tempCtx.drawImage(
                        cropCanvas,
                        0, 0, paddedWidth, paddedHeight,
                        0, 0, paddedWidth * scale, paddedHeight * scale
                    );

                    // Apply filters
                    applyImageFilters(tempCanvas, tempCtx);

                    // If edited, apply the transparency mask from editedCanvas
                    if (item.box.editedCanvas) {
                        const editCanvas = item.box.editedCanvas;

                        // Use destination-in to apply the alpha channel from edited canvas
                        // Scale the mask to match the scaled temp canvas
                        tempCtx.globalCompositeOperation = 'destination-in';
                        tempCtx.drawImage(editCanvas, 0, 0, editCanvas.width, editCanvas.height, 0, 0, paddedWidth * scale, paddedHeight * scale);
                        tempCtx.globalCompositeOperation = 'source-over';
                    }

                    // Calculate Y position based on baseline alignment
                    let yPos = 0;
                    if (item.box.baseline_offset !== undefined && unifiedBaselineY > 0) {
                        // Calculate baseline Y at current horizontal position
                        let baselineYAtCurrentPos = unifiedBaselineY;

                        if (hasAngledBaseline) {
                            // For angled baseline, calculate Y based on horizontal distance and slope
                            baselineYAtCurrentPos = unifiedBaselineY + (offsetX * baselineSlope);
                        }

                        // Align to baseline using stored offset
                        yPos = baselineYAtCurrentPos - (item.box.baseline_offset * scale);
                    } else if (unifiedBaselineY > 0) {
                        // No baseline association but baseline exists - align bottom edge to baseline
                        let baselineYAtCurrentPos = unifiedBaselineY;

                        if (hasAngledBaseline) {
                            baselineYAtCurrentPos = unifiedBaselineY + (offsetX * baselineSlope);
                        }

                        yPos = baselineYAtCurrentPos - paddedHeight * scale;
                    } else {
                        // No baseline at all - center vertically in canvas
                        yPos = (canvasHeight - paddedHeight * scale) / 2;
                    }

                    // Use multiply blend mode for overlapping characters
                    previewCtx.globalCompositeOperation = 'multiply';
                    previewCtx.drawImage(tempCanvas, offsetX, yPos);
                    previewCtx.globalCompositeOperation = 'source-over';

                    // Track character position for hit detection (only for UI)
                    if (!skipUIElements) {
                        const charPos = {
                            box: item.box,
                            x: offsetX,
                            y: yPos,
                            width: paddedWidth * scale,
                            height: paddedHeight * scale
                        };
                        charPositionsInPreview.push(charPos);
                    }

                    offsetX += paddedWidth * scale;
                } else {
                    // Placeholder - just advance offset
                    offsetX += item.width * scale;
                }

                if (i < charImages.length - 1) {
                    // Apply global letter spacing plus per-pair kerning adjustment
                    const pairKerning = kerningAdjustments[i] || 0;
                    offsetX += spacingPixels + (pairKerning * scale);
                }
            }

            // Draw the baseline line for visual reference (only for UI, not for download)
            if (!skipUIElements) {
                if (hasAngledBaseline && unifiedBaselineY > 0) {
                    previewCtx.strokeStyle = angledBaseline.color;
                    previewCtx.lineWidth = 1;
                    previewCtx.setLineDash([5, 3]);
                    previewCtx.beginPath();
                    // Draw from left edge to right edge
                    const baselineYAtStart = unifiedBaselineY;
                    const baselineYAtEnd = unifiedBaselineY + (offsetX * baselineSlope);
                    previewCtx.moveTo(0, baselineYAtStart);
                    previewCtx.lineTo(offsetX, baselineYAtEnd);
                    previewCtx.stroke();
                    previewCtx.setLineDash([]);
                } else if (!hasAngledBaseline && unifiedBaselineY > 0) {
                    // Draw horizontal baseline
                    previewCtx.strokeStyle = '#999';
                    previewCtx.lineWidth = 1;
                    previewCtx.setLineDash([5, 3]);
                    previewCtx.beginPath();
                    previewCtx.moveTo(0, unifiedBaselineY);
                    previewCtx.lineTo(offsetX, unifiedBaselineY);
                    previewCtx.stroke();
                    previewCtx.setLineDash([]);
                }
            }

            document.getElementById('downloadBtn').disabled = boxes.length === 0;

            // Update placeholder indicators canvas (skip if downloading)
            if (!skipUIElements) {
                updatePlaceholderCanvas(charImages, scale, avgCharWidth, letterSpacing);
            }
        }

        function updatePlaceholderCanvas(charImages, scale, avgCharWidth, letterSpacing) {
            const previewCanvas = document.getElementById('wordPreview');
            const placeholderCanvas = document.getElementById('placeholderCanvas');
            const placeholderCtx = placeholderCanvas.getContext('2d');

            if (!previewCanvas) return;

            // Get the logical (CSS) width from the preview canvas
            const previewLogicalWidth = parseInt(previewCanvas.style.width) || previewCanvas.getBoundingClientRect().width;

            const spacingPixels = (letterSpacing / 100) * avgCharWidth * scale;

            // HiDPI support - scale canvas for retina displays
            const dpr = window.devicePixelRatio || 1;
            const displayHeight = 60;

            // Set canvas internal resolution to match DPR
            placeholderCanvas.width = previewLogicalWidth * dpr;
            placeholderCanvas.height = displayHeight * dpr;

            // Set CSS size to displayed size
            placeholderCanvas.style.width = previewLogicalWidth + 'px';
            placeholderCanvas.style.height = displayHeight + 'px';

            // Scale context to account for DPR
            placeholderCtx.scale(dpr, dpr);

            // Clear canvas
            placeholderCtx.fillStyle = '#ffffff';
            placeholderCtx.fillRect(0, 0, previewLogicalWidth, displayHeight);

            // Clear marker positions
            kerningMarkerPositions = [];

            // Render placeholder indicators and kerning markers
            // No need for displayScale anymore - we're working directly in logical coordinates
            let offsetX = 0;
            for (let i = 0; i < charImages.length; i++) {
                const item = charImages[i];

                // Calculate actual width (same as kerning markers)
                let actualWidth;
                if (item.type === 'real') {
                    const paddedX = Math.max(0, item.box.x - charPadding);
                    actualWidth = Math.min(item.box.width + charPadding * 2, image.width - paddedX);
                } else {
                    actualWidth = item.width;
                }

                // Calculate width in logical pixels (no displayScale needed with HiDPI)
                const logicalWidth = actualWidth * scale;

                // Draw placeholder box if needed (top 30px)
                if (item.type === 'placeholder') {
                    const boxWidth = logicalWidth;
                    const boxHeight = 30;

                    // Check if this character has been annotated
                    const isAnnotated = !!charToBox[item.char];
                    const isCurrent = i === currentCharIndex;

                    // Indicator box background - blue if current
                    if (isCurrent) {
                        placeholderCtx.fillStyle = '#E3F2FD';
                    } else {
                        placeholderCtx.fillStyle = '#f9f9f9';
                    }
                    placeholderCtx.fillRect(offsetX, 0, boxWidth, boxHeight);

                    // Indicator box border
                    placeholderCtx.strokeStyle = isCurrent ? '#2196F3' : '#ddd';
                    placeholderCtx.lineWidth = isCurrent ? 2 : 1;
                    placeholderCtx.strokeRect(offsetX, 0, boxWidth, boxHeight);

                    // Character in indicator box - green if unannotated, gray if annotated
                    placeholderCtx.fillStyle = isAnnotated ? '#999' : '#4CAF50';
                    placeholderCtx.font = `bold ${Math.min(boxHeight * 0.6, 18)}px sans-serif`;
                    placeholderCtx.textAlign = 'center';
                    placeholderCtx.textBaseline = 'middle';
                    placeholderCtx.fillText(
                        item.char,
                        offsetX + boxWidth / 2,
                        boxHeight / 2
                    );

                    // Store position for click detection
                    kerningMarkerPositions.push({
                        type: 'placeholder',
                        index: i,
                        char: item.char,
                        x: offsetX,
                        width: boxWidth,
                        isAnnotated: isAnnotated,
                        hitZone: {
                            left: offsetX,
                            right: offsetX + boxWidth,
                            top: 0,
                            bottom: boxHeight
                        }
                    });
                }

                // Draw debug lines for all letters (bottom area, starting at y=30)
                // Green on left edge, orange on right edge
                const debugStartY = 30;
                const lineHeight = 15;

                // Left edge - green
                placeholderCtx.strokeStyle = '#4CAF50';
                placeholderCtx.lineWidth = 2;
                placeholderCtx.beginPath();
                placeholderCtx.moveTo(offsetX, debugStartY);
                placeholderCtx.lineTo(offsetX, debugStartY + lineHeight);
                placeholderCtx.stroke();

                // Right edge - orange
                placeholderCtx.strokeStyle = '#FF9800';
                placeholderCtx.lineWidth = 2;
                placeholderCtx.beginPath();
                placeholderCtx.moveTo(offsetX + logicalWidth, debugStartY);
                placeholderCtx.lineTo(offsetX + logicalWidth, debugStartY + lineHeight);
                placeholderCtx.stroke();

                // Draw blue kerning marker in the middle of this letter (skip first letter)
                // Only show marker if both this character AND the previous character have been drawn
                if (i > 0) {
                    const currentChar = item.char;
                    const previousChar = charImages[i - 1].char;
                    const currentHasBox = item.type === 'real';
                    const previousHasBox = charImages[i - 1].type === 'real';

                    // Only draw kerning marker if both adjacent characters have bounding boxes
                    if (currentHasBox && previousHasBox) {
                        const markerX = offsetX + logicalWidth / 2;

                        // Draw vertical line marker
                        placeholderCtx.strokeStyle = '#2196F3';
                        placeholderCtx.lineWidth = 2;
                        placeholderCtx.setLineDash([4, 4]);
                        placeholderCtx.beginPath();
                        placeholderCtx.moveTo(markerX, debugStartY);
                        placeholderCtx.lineTo(markerX, displayHeight);
                        placeholderCtx.stroke();
                        placeholderCtx.setLineDash([]);

                        // Draw draggable handle at bottom
                        placeholderCtx.fillStyle = '#2196F3';
                        placeholderCtx.fillRect(markerX - 4, displayHeight - 12, 8, 12);

                        // Store marker position for hit detection
                        kerningMarkerPositions.push({
                            index: i - 1,
                            x: markerX,
                            hitZone: {
                                left: markerX - 8,
                                right: markerX + 8,
                                top: debugStartY,
                                bottom: displayHeight
                            }
                        });
                    }
                }

                // Advance by letter width (in internal coordinates)
                offsetX += actualWidth * scale;

                if (i < charImages.length - 1) {
                    const pairKerning = kerningAdjustments[i] || 0;
                    offsetX += spacingPixels + (pairKerning * scale);
                }
            }

            // Update reset kerning button visibility based on whether any kerning adjustments exist
            updateResetKerningButtonVisibility();
        }

        function updateResetKerningButtonVisibility() {
            const resetKerningBtn = document.getElementById('resetAllKerningBtn');
            if (!resetKerningBtn) return;

            // Show button only if there are any kerning adjustments
            const hasKerning = Object.keys(kerningAdjustments).length > 0;
            resetKerningBtn.style.display = hasKerning ? 'flex' : 'none';
        }

        // Store marker positions for hit detection
        let kerningMarkerPositions = [];


        // Kerning marker drag state
        let isDraggingKerning = false;
        let draggedMarkerIndex = -1;
        let kerningDragStartX = 0;
        let kerningDragStartValue = 0;

        function setupKerningMarkerDragging() {
            const placeholderCanvas = document.getElementById('placeholderCanvas');
            if (!placeholderCanvas) {
                console.error('Placeholder canvas not found');
                return;
            }

            placeholderCanvas.addEventListener('mousedown', (e) => {
                const rect = placeholderCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Check if clicking on a marker or placeholder
                for (const marker of kerningMarkerPositions) {
                    if (mouseX >= marker.hitZone.left && mouseX <= marker.hitZone.right &&
                        mouseY >= marker.hitZone.top && mouseY <= marker.hitZone.bottom) {

                        // Handle placeholder click (character selection)
                        if (marker.type === 'placeholder' && !marker.isAnnotated) {
                            currentCharIndex = marker.index;
                            updateUI();
                            updateWordPreview();
                            e.preventDefault();
                            break;
                        }

                        // Handle kerning marker drag (only if not a placeholder)
                        if (!marker.type) {
                            isDraggingKerning = true;
                            draggedMarkerIndex = marker.index;
                            kerningDragStartX = mouseX;
                            kerningDragStartValue = kerningAdjustments[marker.index] || 0;
                            placeholderCanvas.style.cursor = 'ew-resize';
                            e.preventDefault();
                            break;
                        }
                    }
                }
            });

            placeholderCanvas.addEventListener('mousemove', (e) => {
                const rect = placeholderCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                if (isDraggingKerning) {
                    // Calculate drag distance in canvas pixels
                    const deltaX = mouseX - kerningDragStartX;
                    // Convert to unscaled pixels (scale is 2 in updateWordPreview)
                    const scale = 2;
                    const kerningAdjustment = kerningDragStartValue + (deltaX / scale);

                    // Update kerning for this pair
                    kerningAdjustments[draggedMarkerIndex] = kerningAdjustment;

                    // Redraw preview with new kerning
                    updateWordPreview();
                } else {
                    // Update cursor based on hover
                    let cursor = 'default';
                    for (const marker of kerningMarkerPositions) {
                        if (mouseX >= marker.hitZone.left && mouseX <= marker.hitZone.right &&
                            mouseY >= marker.hitZone.top && mouseY <= marker.hitZone.bottom) {
                            // Clickable placeholder (unannotated character)
                            if (marker.type === 'placeholder' && !marker.isAnnotated) {
                                cursor = 'pointer';
                                break;
                            }
                            // Kerning marker (draggable spacing adjustment)
                            if (!marker.type) {
                                cursor = 'ew-resize';
                                break;
                            }
                        }
                    }
                    placeholderCanvas.style.cursor = cursor;
                }
            });

            placeholderCanvas.addEventListener('mouseup', () => {
                isDraggingKerning = false;
                draggedMarkerIndex = -1;
            });

            placeholderCanvas.addEventListener('mouseleave', () => {
                isDraggingKerning = false;
                draggedMarkerIndex = -1;
                placeholderCanvas.style.cursor = 'default';
            });
        }

        function resetAllKerning() {
            // Clear all kerning adjustments
            kerningAdjustments = {};
            console.log('ðŸ”„ Reset all kerning adjustments');
            // Update the word preview to reflect the reset
            updateWordPreview();
        }

        // Tesseract.js Auto-Solve Function
        function startAutoSolveRegionSelection() {
            console.log('ðŸ”® Starting auto-solve region selection...');

            // Check if string is set
            if (!text || text.length === 0) {
                alert('Please write a string first before using auto-solve.');
                return;
            }

            // Check if image is loaded
            if (!image) {
                alert('Please upload an image first.');
                return;
            }

            // Deactivate other tools
            isRotationMode = false;
            isAngledBaselineMode = false;
            isBrushBoxMode = false;
            isBaselineMode = false;
            currentTool = null;

            // Clear any in-progress tool states
            angledBaselineStart = null;
            angledBaselineEnd = null;
            angledBaselineFinalized = false;

            // Reset all tool button states to inactive
            document.querySelectorAll('.tool-button').forEach(btn => {
                if (btn.id !== 'autoSolveBtn') {
                    btn.style.background = '#f5f5f5';
                    btn.style.color = '#333';
                    btn.style.border = '1px solid #ddd';
                }
            });

            // Hide all mode controls and character box
            document.getElementById('rotationModeControls').style.display = 'none';
            document.getElementById('brushModeControls').style.display = 'none';
            document.getElementById('angledBaselineModeControls').style.display = 'none';
            document.getElementById('boxModeControls').style.display = 'none';
            document.getElementById('baselineModeControls').style.display = 'none';
            document.getElementById('noStringModeControls').style.display = 'none';
            document.getElementById('noToolModeControls').style.display = 'none';
            document.getElementById('modeSeparator').style.display = 'none';
            const charBoxContainer = document.getElementById('currentCharBoxContainer');
            if (charBoxContainer) charBoxContainer.style.display = 'none';

            // Enter region selection mode
            isSelectingAutoSolveRegion = true;
            autoSolveRegions = [];
            currentAutoSolveRegion = null;
            autoSolveRegionStart = null;

            // Update button to show active state
            const autoSolveBtn = document.getElementById('autoSolveBtn');
            autoSolveBtn.style.background = '#2196F3';
            autoSolveBtn.style.color = 'white';
            autoSolveBtn.style.border = 'none';

            // Show floating action buttons and mode controls
            updateAutoSolveControls();
        }

        function updateAutoSolveControls() {
            const floatingContainer = document.getElementById('floatingActionButtonsContainer');
            const modeControls = document.getElementById('autoSolveModeControls');
            const modeSeparator = document.getElementById('modeSeparator');

            if (isSelectingAutoSolveRegion) {
                // Show mode controls
                modeControls.style.display = 'flex';
                modeSeparator.style.display = 'block';

                // Only show confirm/cancel buttons if at least one region has been drawn
                if (autoSolveRegions.length > 0) {
                    floatingContainer.style.display = 'block';
                    syncFloatingElementHeights();
                } else {
                    floatingContainer.style.display = 'none';
                }
            } else {
                // Hide mode controls and buttons
                modeControls.style.display = 'none';
                modeSeparator.style.display = 'none';
                floatingContainer.style.display = 'none';
            }
        }

        function cancelAutoSolveRegions() {
            isSelectingAutoSolveRegion = false;
            autoSolveRegions = [];
            currentAutoSolveRegion = null;
            autoSolveRegionStart = null;

            // Reset button appearance
            const autoSolveBtn = document.getElementById('autoSolveBtn');
            autoSolveBtn.style.background = '#f5f5f5';
            autoSolveBtn.style.color = '#333';
            autoSolveBtn.style.border = '1px solid #ddd';

            updateAutoSolveControls();
            updateNoToolModeControls();
            redraw();
            console.log('âŒ Auto-solve cancelled');
        }

        async function confirmAutoSolveRegions() {
            if (autoSolveRegions.length === 0) {
                alert('Please draw at least one region first.');
                return;
            }

            // Exit selection mode
            isSelectingAutoSolveRegion = false;
            updateAutoSolveControls();

            console.log(`ðŸ“¦ Processing ${autoSolveRegions.length} region(s)`);

            const autoSolveBtn = document.getElementById('autoSolveBtn');
            const originalBtnHTML = autoSolveBtn.innerHTML;

            try {
                // Disable button and show loading state
                autoSolveBtn.disabled = true;
                autoSolveBtn.innerHTML = '<i data-feather="loader" style="width: 16px; height: 16px; animation: spin 1s linear infinite;"></i> Processing...';
                feather.replace();

                // Create Tesseract worker
                console.log('ðŸ“¦ Creating Tesseract worker...');
                const worker = await Tesseract.createWorker('eng', 1, {
                    logger: m => console.log('Tesseract:', m)
                });

                // Get canvas image data (including rotation if applied)
                // First, draw full rotated image to a temp canvas
                const fullCanvas = document.createElement('canvas');
                fullCanvas.width = image.width;
                fullCanvas.height = image.height;
                const fullCtx = fullCanvas.getContext('2d');

                // Apply rotation if there is any
                if (imageRotation !== 0) {
                    fullCtx.save();
                    fullCtx.translate(fullCanvas.width / 2, fullCanvas.height / 2);
                    fullCtx.rotate(imageRotation * Math.PI / 180);
                    fullCtx.translate(-fullCanvas.width / 2, -fullCanvas.height / 2);
                    fullCtx.drawImage(image, 0, 0, fullCanvas.width, fullCanvas.height);
                    fullCtx.restore();
                    console.log(`ðŸ”„ Applied ${imageRotation}Â° rotation to image for OCR`);
                } else {
                    fullCtx.drawImage(image, 0, 0);
                }

                // Process all regions
                let addedCount = 0;
                let skippedCount = 0;
                const allMatches = {};

                for (let regionIndex = 0; regionIndex < autoSolveRegions.length; regionIndex++) {
                    const region = autoSolveRegions[regionIndex];
                    console.log(`\nðŸ“¦ Processing region ${regionIndex + 1}/${autoSolveRegions.length}`);

                    // Crop to selected region
                    const cropCanvas = document.createElement('canvas');
                    cropCanvas.width = region.width;
                    cropCanvas.height = region.height;
                    const cropCtx = cropCanvas.getContext('2d');

                    // Copy the selected region from full canvas
                    cropCtx.drawImage(
                        fullCanvas,
                        region.x, region.y, region.width, region.height,
                        0, 0, region.width, region.height
                    );

                    console.log(`âœ‚ï¸ Cropped to region: ${region.width}x${region.height} at (${region.x}, ${region.y})`);

                    const imageData = cropCanvas.toDataURL('image/png');

                    // Run OCR
                    console.log('ðŸ” Running OCR on region...');
                    const result = await worker.recognize(imageData);

                    // Extract symbols
                    const symbols = result.data.symbols || [];
                    console.log(`âœ… Found ${symbols.length} symbols in region`);

                    // Match symbols to our string
                    const matches = matchSymbolsToString(symbols, text);
                    console.log('ðŸŽ¯ Matched symbols:', matches);

                    // Add matches to combined results, with region offset
                    for (const [char, symbol] of Object.entries(matches)) {
                        // Only keep highest confidence match for each character across all regions
                        if (!allMatches[char] || symbol.confidence > allMatches[char].symbol.confidence) {
                            allMatches[char] = {
                                symbol: symbol,
                                region: region
                            };
                        }
                    }
                }

                // Create bounding boxes from best matches
                for (const [char, match] of Object.entries(allMatches)) {
                    // Skip if this character already has a box
                    if (charToBox[char]) {
                        console.log(`â­ï¸ Skipping '${char}' - already has a box`);
                        skippedCount++;
                        continue;
                    }

                    // Create box from Tesseract bbox with 5px padding on all sides
                    // Note: Tesseract bbox is relative to cropped region, so we need to offset it
                    const PADDING = 5;
                    const box = {
                        x: Math.max(0, match.region.x + match.symbol.bbox.x0 - PADDING),
                        y: Math.max(0, match.region.y + match.symbol.bbox.y0 - PADDING),
                        width: (match.symbol.bbox.x1 - match.symbol.bbox.x0) + (PADDING * 2),
                        height: (match.symbol.bbox.y1 - match.symbol.bbox.y0) + (PADDING * 2),
                        char: char
                    };

                    // Ensure box doesn't exceed image bounds
                    if (box.x + box.width > image.width) {
                        box.width = image.width - box.x;
                    }
                    if (box.y + box.height > image.height) {
                        box.height = image.height - box.y;
                    }

                    // Add to boxes array and charToBox mapping
                    boxes.push(box);
                    charToBox[char] = box;
                    addedCount++;
                    console.log(`âœ¨ Added box for '${char}' at (${box.x}, ${box.y}) ${box.width}x${box.height} with ${PADDING}px padding - Confidence: ${match.symbol.confidence.toFixed(1)}%`);
                }

                // Terminate worker
                await worker.terminate();
                console.log('ðŸ§¹ Tesseract worker terminated');

                // Update UI
                currentCharIndex = findNextUnannotatedChar();
                redraw();
                updateUI();
                updateWordPreview();

                // Clear regions after successful processing
                autoSolveRegions = [];

                // Show results
                const totalChars = uniqueChars.length;
                const remaining = totalChars - (addedCount + skippedCount);
                alert(`Auto-Solve Complete!\n\nâœ… Added: ${addedCount} character${addedCount !== 1 ? 's' : ''}\nâ­ï¸ Skipped: ${skippedCount} (already annotated)\nðŸ“ Remaining: ${remaining} character${remaining !== 1 ? 's' : ''}`);

            } catch (error) {
                console.error('âŒ Auto-solve error:', error);
                alert(`Auto-solve failed: ${error.message}\n\nYou can continue annotating manually.`);
            } finally {
                // Re-enable button and reset appearance
                autoSolveBtn.disabled = false;
                autoSolveBtn.innerHTML = originalBtnHTML;
                autoSolveBtn.style.background = '#f5f5f5';
                autoSolveBtn.style.color = '#333';
                autoSolveBtn.style.border = '1px solid #ddd';
                feather.replace();
            }
        }

        // Match Tesseract symbols to our target string
        function matchSymbolsToString(tesseractSymbols, targetString) {
            console.log('ðŸ” Matching symbols to target string:', targetString);

            // Filter out low-confidence and empty symbols
            const MIN_CONFIDENCE = 60; // Lower threshold to catch more characters
            const validSymbols = tesseractSymbols.filter(s =>
                s.text &&
                s.text.trim().length > 0 &&
                s.confidence >= MIN_CONFIDENCE &&
                s.bbox &&
                s.bbox.x1 > s.bbox.x0 &&
                s.bbox.y1 > s.bbox.y0
            );

            console.log(`ðŸ“Š Filtered to ${validSymbols.length} valid symbols (confidence â‰¥ ${MIN_CONFIDENCE}%)`);

            // Sort symbols left-to-right by x position
            const sorted = validSymbols.sort((a, b) => a.bbox.x0 - b.bbox.x0);

            // Build a map of characters to their best matching symbols
            const matches = {};

            // For each unique character in our string
            for (const targetChar of uniqueChars) {
                // Find all symbols that match this character (case-insensitive)
                const candidates = sorted.filter(s =>
                    s.text.toLowerCase() === targetChar.toLowerCase()
                );

                if (candidates.length > 0) {
                    // Pick the highest confidence match
                    const best = candidates.reduce((prev, curr) =>
                        curr.confidence > prev.confidence ? curr : prev
                    );

                    matches[targetChar] = best;
                    console.log(`âœ“ Matched '${targetChar}' with confidence ${best.confidence.toFixed(1)}%`);
                } else {
                    console.log(`âœ— No match found for '${targetChar}'`);
                }
            }

            return matches;
        }

        // Wait for user to draw region selection box
        function waitForRegionSelection() {
            return new Promise((resolve) => {
                // Store resolve function to call when region is selected
                window.autoSolveRegionResolve = resolve;
            });
        }

        function setupResizeHandle() {
            const resizeHandle = document.getElementById('resizeHandle');
            const annotationSection = document.getElementById('annotationSection');
            const wordPreviewSection = document.getElementById('wordPreviewSection');

            if (!resizeHandle || !annotationSection || !wordPreviewSection) {
                console.error('Resize elements not found');
                return;
            }

            let isResizing = false;
            let startY = 0;
            let startAnnotationHeight = 0;
            let startPreviewHeight = 0;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startY = e.clientY;
                startAnnotationHeight = annotationSection.offsetHeight;
                startPreviewHeight = wordPreviewSection.offsetHeight;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const deltaY = e.clientY - startY;
                const newAnnotationHeight = startAnnotationHeight + deltaY;
                const newPreviewHeight = startPreviewHeight - deltaY;

                // Enforce minimum heights
                if (newAnnotationHeight >= 200 && newPreviewHeight >= 150) {
                    annotationSection.style.flex = `0 0 ${newAnnotationHeight}px`;
                    wordPreviewSection.style.flex = `0 0 ${newPreviewHeight}px`;
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    // Update word preview and annotation canvas based on new container size
                    updateWordPreview();
                    updateCanvasContainerLayout();
                }
            });
        }

        function setupToolPalette() {
            // Tool buttons
            document.getElementById('toolBoundingBox').addEventListener('click', () => setTool('boundingBox'));
            document.getElementById('toolBaseline').addEventListener('click', () => setTool('baseline'));
            document.getElementById('toolRotation').addEventListener('click', () => setTool('rotation'));
            document.getElementById('toolAngledBaseline').addEventListener('click', () => setTool('angledBaseline'));
            document.getElementById('toolBrushBox').addEventListener('click', () => setTool('brushBox'));
        }

        function setTool(tool) {
            // Exit previous modes
            isRotationMode = false;
            isAngledBaselineMode = false;
            isBrushBoxMode = false;
            isBaselineMode = false;

            // Cancel auto-solve if it was active
            if (isSelectingAutoSolveRegion) {
                cancelAutoSolveRegions();
            }

            // Clear any in-progress angled baseline drawing
            if (tool !== 'angledBaseline') {
                angledBaselineStart = null;
                angledBaselineEnd = null;
                angledBaselineFinalized = false;
            }

            // Set new tool
            currentTool = tool;

            // Update button states
            document.querySelectorAll('.tool-button').forEach(btn => {
                btn.style.background = '#f5f5f5';
                btn.style.color = '#333';
                btn.style.border = '1px solid #ddd';
            });

            // Highlight active tool
            const activeBtn = document.getElementById(`tool${tool.charAt(0).toUpperCase() + tool.slice(1)}`);
            if (activeBtn) {
                activeBtn.style.background = '#2196F3';
                activeBtn.style.color = 'white';
                activeBtn.style.border = 'none';
            }

            // Hide all mode controls, separator, character box, and action buttons
            document.getElementById('rotationModeControls').style.display = 'none';
            document.getElementById('brushModeControls').style.display = 'none';
            document.getElementById('angledBaselineModeControls').style.display = 'none';
            document.getElementById('boxModeControls').style.display = 'none';
            document.getElementById('baselineModeControls').style.display = 'none';
            document.getElementById('autoSolveModeControls').style.display = 'none';
            document.getElementById('noStringModeControls').style.display = 'none';
            document.getElementById('noToolModeControls').style.display = 'none';
            document.getElementById('modeSeparator').style.display = 'none';
            const charBoxContainer = document.getElementById('currentCharBoxContainer');
            const actionButtonsContainer = document.getElementById('floatingActionButtonsContainer');
            if (charBoxContainer) charBoxContainer.style.display = 'none';
            if (actionButtonsContainer) actionButtonsContainer.style.display = 'none';

            // Activate the appropriate mode
            if (tool === 'rotation') {
                isRotationMode = true;
                document.getElementById('rotationModeControls').style.display = 'flex';
                document.getElementById('modeSeparator').style.display = 'block';
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'angledBaseline') {
                isAngledBaselineMode = true;
                document.getElementById('angledBaselineModeControls').style.display = 'flex';
                document.getElementById('modeSeparator').style.display = 'block';
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'brushBox') {
                isBrushBoxMode = true;
                document.getElementById('brushModeControls').style.display = 'flex';
                document.getElementById('modeSeparator').style.display = 'block';
                canvas.style.cursor = 'crosshair';
                updateBrushModeControls();
                initBrushBoxCanvas();
            } else if (tool === 'baseline') {
                isBaselineMode = true;
                document.getElementById('baselineModeControls').style.display = 'flex';
                document.getElementById('modeSeparator').style.display = 'block';
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'boundingBox') {
                document.getElementById('boxModeControls').style.display = 'flex';
                document.getElementById('modeSeparator').style.display = 'block';
                updateBoxModeText();
                canvas.style.cursor = 'crosshair';
            } else {
                canvas.style.cursor = 'crosshair';
            }

            redraw();
            syncFloatingElementHeights();
            updateNoToolModeControls();
        }

        function syncFloatingElementHeights() {
            // Sync the heights of character box and action buttons with tool palette
            const toolPalette = document.getElementById('toolPalette');
            const charBoxContainer = document.getElementById('currentCharBoxContainer');
            const actionButtonsContainer = document.getElementById('floatingActionButtonsContainer');

            if (!toolPalette) return;

            // Use requestAnimationFrame to ensure DOM has updated
            requestAnimationFrame(() => {
                const paletteHeight = toolPalette.offsetHeight;

                if (charBoxContainer) {
                    charBoxContainer.style.height = paletteHeight + 'px';
                }

                if (actionButtonsContainer) {
                    actionButtonsContainer.style.height = paletteHeight + 'px';
                }
            });
        }

        function updateBoxModeText() {
            const textEl = document.getElementById('boxModeText');
            const charBoxContainer = document.getElementById('currentCharBoxContainer');
            const charDisplay = document.getElementById('currentCharDisplay');
            if (!textEl) return;

            console.log('ðŸ“ updateBoxModeText:');
            console.log('  currentCharIndex:', currentCharIndex);
            console.log('  uniqueChars.length:', uniqueChars.length);
            console.log('  currentTool:', currentTool);

            if (!text || text.trim() === '') {
                console.log('  No text set');
                // No string set yet - show prompt with button, hide char box
                textEl.innerHTML = `
                    <span style="font-size: 11px; color: #666;">Write a string to begin:</span>
                    <button onclick="document.getElementById('writeStringBtn').click()" style="padding: 4px 10px; font-size: 11px; height: 26px; margin-left: 8px; background: #2196F3; color: white; border: none; border-radius: 3px; cursor: pointer; display: inline-flex; align-items: center; gap: 4px;">
                        <i data-feather="edit-3" style="width: 12px; height: 12px;"></i> Write String
                    </button>
                `;
                if (charBoxContainer) charBoxContainer.style.display = 'none';
                // Re-render feather icons after updating innerHTML
                feather.replace();
            } else if (currentCharIndex < uniqueChars.length) {
                const currentChar = uniqueChars[currentCharIndex];
                console.log(`  Showing char '${currentChar}' at index ${currentCharIndex}`);
                textEl.innerHTML = `<span style="font-size: 11px; color: #666;">Draw a bounding box for the letter to the left</span>`;
                // Only show character box if boundingBox tool is active
                if (currentTool === 'boundingBox') {
                    if (charBoxContainer) charBoxContainer.style.display = 'block';
                    if (charDisplay) charDisplay.textContent = currentChar;
                } else {
                    if (charBoxContainer) charBoxContainer.style.display = 'none';
                }
            } else {
                console.log('  All unique characters annotated');
                textEl.innerHTML = '<span style="font-size: 11px; color: #666;">All characters annotated</span>';
                if (charBoxContainer) charBoxContainer.style.display = 'none';
            }
            syncFloatingElementHeights();
        }

        function updateBrushModeControls() {
            const promptEl = document.getElementById('brushModePrompt');
            const sliderEl = document.getElementById('brushModeSlider');
            const charBoxContainer = document.getElementById('currentCharBoxContainer');
            const charDisplay = document.getElementById('currentCharDisplay');
            if (!promptEl || !sliderEl) return;

            if (!text || text.trim() === '') {
                // No string set - show prompt, hide char box
                promptEl.style.display = 'block';
                sliderEl.style.display = 'none';
                if (charBoxContainer) charBoxContainer.style.display = 'none';
                // Re-render feather icons
                feather.replace();
            } else {
                // String is set - show brush controls and char box
                promptEl.style.display = 'none';
                sliderEl.style.display = 'flex';
                if (currentCharIndex < uniqueChars.length) {
                    const currentChar = uniqueChars[currentCharIndex];
                    // Only show character box if brushBox tool is active
                    if (currentTool === 'brushBox') {
                        if (charBoxContainer) charBoxContainer.style.display = 'block';
                        if (charDisplay) charDisplay.textContent = currentChar;
                    } else {
                        if (charBoxContainer) charBoxContainer.style.display = 'none';
                    }
                } else {
                    if (charBoxContainer) charBoxContainer.style.display = 'none';
                }
            }
            syncFloatingElementHeights();
        }

        function updateBrushSize(e) {
            brushBoxSize = parseInt(e.target.value);
            document.getElementById('brushSizeDisplay').textContent = brushBoxSize + 'px';
        }

        function updateBrushActionButtons() {
            const buttonsContainer = document.getElementById('floatingActionButtonsContainer');
            if (!buttonsContainer || !brushBoxCanvas) return;

            // Check if there's any content on the brush canvas
            const imageData = brushBoxCtx.getImageData(0, 0, brushBoxCanvas.width, brushBoxCanvas.height);
            const data = imageData.data;
            let hasContent = false;

            // Quick check for any non-transparent pixels
            for (let i = 3; i < data.length; i += 4) {
                if (data[i] > 0) {
                    hasContent = true;
                    break;
                }
            }

            // Show/hide floating buttons container based on content
            buttonsContainer.style.display = hasContent ? 'block' : 'none';
            syncFloatingElementHeights();
        }

        function initBrushBoxCanvas() {
            // Create a temporary canvas for brush strokes
            if (!brushBoxCanvas) {
                brushBoxCanvas = document.createElement('canvas');
                brushBoxCtx = brushBoxCanvas.getContext('2d');
            }
            brushBoxCanvas.width = image.width;
            brushBoxCanvas.height = image.height;
            brushBoxCtx.clearRect(0, 0, brushBoxCanvas.width, brushBoxCanvas.height);
            updateBrushActionButtons();
        }

        function confirmBrushBox() {
            console.log('ðŸ–Œï¸ confirmBrushBox called');

            // Auto-fill enclosed areas using flood fill
            autoFillEnclosedAreas();

            // Convert brush strokes to bounding box with mask
            const imageData = brushBoxCtx.getImageData(0, 0, brushBoxCanvas.width, brushBoxCanvas.height);
            const data = imageData.data;

            let minX = brushBoxCanvas.width;
            let minY = brushBoxCanvas.height;
            let maxX = 0;
            let maxY = 0;
            let hasContent = false;

            // Find bounds of all painted pixels
            for (let y = 0; y < brushBoxCanvas.height; y++) {
                for (let x = 0; x < brushBoxCanvas.width; x++) {
                    const alpha = data[(y * brushBoxCanvas.width + x) * 4 + 3];
                    if (alpha > 0) {
                        hasContent = true;
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            console.log('ðŸ“Š hasContent:', hasContent, 'text:', text, 'currentCharIndex:', currentCharIndex);

            if (hasContent && text && currentCharIndex < queryPositionToChar.length) {
                const char = queryPositionToChar[currentCharIndex];
                console.log('âœï¸ Creating box for character:', char);

                // Create a masked canvas with actual image pixels
                const maskWidth = maxX - minX + 1;
                const maskHeight = maxY - minY + 1;
                const maskedCanvas = document.createElement('canvas');
                maskedCanvas.width = maskWidth;
                maskedCanvas.height = maskHeight;
                const maskedCtx = maskedCanvas.getContext('2d');

                // Draw the image region
                maskedCtx.drawImage(
                    image,
                    minX, minY, maskWidth, maskHeight,
                    0, 0, maskWidth, maskHeight
                );

                // Get the mask data
                const maskImageData = brushBoxCtx.getImageData(minX, minY, maskWidth, maskHeight);
                const maskData = maskImageData.data;

                // Get the image data
                const imageImageData = maskedCtx.getImageData(0, 0, maskWidth, maskHeight);
                const imageData = imageImageData.data;

                // Apply mask: set alpha to 0 where mask is transparent
                for (let i = 0; i < maskData.length; i += 4) {
                    const maskAlpha = maskData[i + 3];
                    if (maskAlpha === 0) {
                        // No mask here - make transparent
                        imageData[i + 3] = 0;
                    }
                }

                // Put the masked image back
                maskedCtx.putImageData(imageImageData, 0, 0);

                // Create the box with the edited canvas
                const box = {
                    char: char,
                    x: minX,
                    y: minY,
                    width: maskWidth,
                    height: maskHeight,
                    editedCanvas: maskedCanvas  // Store mask on box for word preview
                };

                // Associate with baseline if one exists
                const baselineInfo = findClosestBaseline(box.y, box.height, box.x, box.width);
                if (baselineInfo) {
                    box.baseline_id = baselineInfo.baseline_id;
                    box.baseline_offset = baselineInfo.baseline_offset;
                }

                // Remove old box for this character if it exists
                if (charToBox[char]) {
                    const oldBox = charToBox[char];
                    const oldBoxIndex = boxes.indexOf(oldBox);
                    if (oldBoxIndex !== -1) {
                        boxes.splice(oldBoxIndex, 1);
                        console.log('ðŸ—‘ï¸ Removed old box for char:', char);
                    }
                }

                boxes.push(box);
                charToBox[char] = box;

                console.log('ðŸ“¦ Box added - boxes.length:', boxes.length, 'charToBox:', Object.keys(charToBox));

                // Also store in editedChars for the edited list UI
                editedChars[char] = maskedCanvas;

                console.log('ðŸŽ¨ editedChars updated:', Object.keys(editedChars));

                // Move to next character
                const oldCharIndex = currentCharIndex;
                currentCharIndex = findNextUnannotatedChar();
                console.log('âž¡ï¸ Moving from character index', oldCharIndex, 'to', currentCharIndex);

                // Clear brush canvas completely
                if (brushBoxCanvas) {
                    brushBoxCtx.clearRect(0, 0, brushBoxCanvas.width, brushBoxCanvas.height);
                    console.log('ðŸ§¹ Brush canvas cleared');
                }

                // Reset brush drawing state but stay in brush mode
                isBrushBoxDrawing = false;
                updateBrushActionButtons();
                console.log('ðŸ”§ Brush drawing state reset');

                // Force complete UI refresh with a slight delay to ensure state is updated
                setTimeout(() => {
                    console.log('ðŸ”„ Running deferred updates...');
                    redraw();
                    updateBoxList();
                    updateEditedCharsList();
                    updateWordPreview();
                    updateBrushModeControls(); // Update character display in tool panel
                    console.log('âœ… All updates complete');
                }, 0);
            } else {
                console.log('âŒ Cannot create box - hasContent:', hasContent, 'text:', text, 'currentCharIndex:', currentCharIndex, 'queryPositionToChar.length:', queryPositionToChar.length);
            }
        }

        function autoFillEnclosedAreas() {
            // Detect and fill enclosed areas in the brush strokes
            const imageData = brushBoxCtx.getImageData(0, 0, brushBoxCanvas.width, brushBoxCanvas.height);
            const data = imageData.data;
            const width = brushBoxCanvas.width;
            const height = brushBoxCanvas.height;

            // Create a visited array to track flood fill
            const visited = new Array(width * height).fill(false);

            // Helper function to check if a pixel is painted
            function isPainted(x, y) {
                if (x < 0 || x >= width || y < 0 || y >= height) return false;
                const idx = (y * width + x) * 4 + 3;
                return data[idx] > 0;
            }

            // Flood fill from a point - returns true if it hits the edge (not enclosed)
            function floodFill(startX, startY, fillList) {
                const stack = [[startX, startY]];
                let hitEdge = false;

                while (stack.length > 0) {
                    const [x, y] = stack.pop();

                    if (x < 0 || x >= width || y < 0 || y >= height) {
                        hitEdge = true;
                        continue;
                    }

                    const idx = y * width + x;
                    if (visited[idx] || isPainted(x, y)) continue;

                    visited[idx] = true;
                    fillList.push([x, y]);

                    // Check 4-connected neighbors
                    stack.push([x + 1, y]);
                    stack.push([x - 1, y]);
                    stack.push([x, y + 1]);
                    stack.push([x, y - 1]);
                }

                return hitEdge;
            }

            // Find all unpainted regions
            const enclosedRegions = [];

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (!visited[idx] && !isPainted(x, y)) {
                        const fillList = [];
                        const hitEdge = floodFill(x, y, fillList);

                        // If this region didn't hit the edge, it's enclosed
                        if (!hitEdge && fillList.length > 0) {
                            enclosedRegions.push(fillList);
                        }
                    }
                }
            }

            // Fill all enclosed regions
            brushBoxCtx.fillStyle = 'rgba(76, 175, 80, 0.5)';
            enclosedRegions.forEach(region => {
                region.forEach(([x, y]) => {
                    brushBoxCtx.fillRect(x, y, 1, 1);
                });
            });
        }

        function cancelBrushBox() {
            // Clear brush strokes
            if (brushBoxCtx) {
                brushBoxCtx.clearRect(0, 0, brushBoxCanvas.width, brushBoxCanvas.height);
            }
            updateBrushActionButtons();
            redraw();
        }

        function resetAngledBaseline() {
            // Reset the drawing state to allow drawing a new angled baseline
            angledBaselineStart = null;
            angledBaselineEnd = null;
            angledBaselineFinalized = false;
            angledBaselineAngle = 0;
            document.getElementById('angledBaselineDisplay').textContent = '0Â°';
            redraw();
        }

        function autoAdjustLevels() {
            const previewCanvas = document.getElementById('wordPreview');
            if (!previewCanvas || previewCanvas.width === 0) {
                alert('Please annotate some characters first to generate a word preview.');
                return;
            }

            // Save current invert state and temporarily disable it for analysis
            const originalInvert = imageFilters.invert;
            imageFilters.invert = false;

            // Re-render without invert to analyze the base image
            updateWordPreview();

            const ctx = previewCanvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);
            const data = imageData.data;

            // Build luminance histogram (0-255)
            const histogram = new Array(256).fill(0);
            let totalPixels = 0;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const alpha = data[i + 3];

                // Skip transparent pixels (background)
                if (alpha < 10) continue;

                // Calculate luminance
                const luminance = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                histogram[luminance]++;
                totalPixels++;
            }

            if (totalPixels === 0) {
                alert('No visible pixels to analyze.');
                return;
            }

            // Find min/max luminance with 5% outlier clipping (more aggressive)
            const clipThreshold = totalPixels * 0.05;
            let minLuminance = 0;
            let maxLuminance = 255;
            let accumulated = 0;

            // Find min (skip darkest 5%)
            for (let i = 0; i < 256; i++) {
                accumulated += histogram[i];
                if (accumulated > clipThreshold) {
                    minLuminance = i;
                    break;
                }
            }

            // Find max (skip brightest 5%)
            accumulated = 0;
            for (let i = 255; i >= 0; i--) {
                accumulated += histogram[i];
                if (accumulated > clipThreshold) {
                    maxLuminance = i;
                    break;
                }
            }

            // Prevent division by zero
            if (maxLuminance <= minLuminance) {
                alert('Image has insufficient tonal range for auto adjustment.');
                return;
            }

            // Calculate adjustments
            const currentRange = maxLuminance - minLuminance;
            const targetRange = 255;
            const midpoint = (minLuminance + maxLuminance) / 2;

            // Contrast: moderate boost for separation without overdoing it
            const contrastAdjust = Math.round((targetRange / currentRange) * 100);
            const boostedContrast = Math.round(contrastAdjust * 1.15); // 15% boost (reduced from 20%)
            const finalContrast = Math.min(200, Math.max(120, boostedContrast)); // Minimum 120

            // Brightness: boost higher to compensate for aggressive shadows
            const brightnessShift = 128 - midpoint;
            const brightnessAdjust = Math.round(100 + (brightnessShift / 255) * 80 + 18); // Higher offset (+18)
            const finalBrightness = Math.min(150, Math.max(105, brightnessAdjust)); // Raised minimum to 105

            // Analyze dark/light distribution for shadows/highlights
            let darkPixels = 0;
            let lightPixels = 0;
            for (let i = 0; i < 128; i++) darkPixels += histogram[i];
            for (let i = 128; i < 256; i++) lightPixels += histogram[i];

            const darkRatio = darkPixels / totalPixels;
            const lightRatio = lightPixels / totalPixels;

            // Shadows: very aggressively darken shadows to crush blacks
            let shadowsAdjust = -60; // Default: heavily darken shadows
            if (darkRatio > 0.7) {
                // If already extremely dark, lift them a bit
                shadowsAdjust = Math.round((darkRatio - 0.8) * 100 - 40);
            }
            const finalShadows = Math.min(0, Math.max(-100, shadowsAdjust));

            // Highlights: very aggressively brighten highlights to blow out whites
            let highlightsAdjust = 75; // Default: heavily brighten highlights (raised from 70)
            if (lightRatio > 0.7) {
                // If already extremely bright, reduce slightly but keep aggressive
                highlightsAdjust = Math.round((0.8 - lightRatio) * 100 + 60);
            }
            const finalHighlights = Math.min(100, Math.max(55, highlightsAdjust)); // Raised minimum to 55

            // Update sliders and values
            imageFilters.brightness = finalBrightness;
            imageFilters.contrast = finalContrast;
            imageFilters.shadows = finalShadows;
            imageFilters.highlights = finalHighlights;

            document.getElementById('brightnessSlider').value = finalBrightness;
            document.getElementById('brightnessValue').textContent = finalBrightness;
            document.getElementById('contrastSlider').value = finalContrast;
            document.getElementById('contrastValue').textContent = finalContrast;
            document.getElementById('shadowsSlider').value = finalShadows;
            document.getElementById('shadowsValue').textContent = finalShadows;
            document.getElementById('highlightsSlider').value = finalHighlights;
            document.getElementById('highlightsValue').textContent = finalHighlights;

            // Restore original invert state
            imageFilters.invert = originalInvert;

            // Update reset button state
            updateResetButtonState();

            // Apply the changes with invert restored
            updateWordPreview();
        }

        function applyImageFilters(canvas, ctx) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                let r = data[i];
                let g = data[i + 1];
                let b = data[i + 2];

                // Grayscale
                if (imageFilters.grayscale > 0) {
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    const grayAmount = imageFilters.grayscale / 100;
                    r = r * (1 - grayAmount) + gray * grayAmount;
                    g = g * (1 - grayAmount) + gray * grayAmount;
                    b = b * (1 - grayAmount) + gray * grayAmount;
                }

                // Brightness
                const brightnessFactor = imageFilters.brightness / 100;
                r *= brightnessFactor;
                g *= brightnessFactor;
                b *= brightnessFactor;

                // Contrast
                const contrastFactor = imageFilters.contrast / 100;
                r = ((r / 255 - 0.5) * contrastFactor + 0.5) * 255;
                g = ((g / 255 - 0.5) * contrastFactor + 0.5) * 255;
                b = ((b / 255 - 0.5) * contrastFactor + 0.5) * 255;

                // Shadows (darken dark areas)
                if (imageFilters.shadows !== 0) {
                    const luminance = (r + g + b) / 3;
                    if (luminance < 128) {
                        const shadowFactor = 1 + (imageFilters.shadows / 100) * (1 - luminance / 128);
                        r *= shadowFactor;
                        g *= shadowFactor;
                        b *= shadowFactor;
                    }
                }

                // Highlights (brighten light areas)
                if (imageFilters.highlights !== 0) {
                    const luminance = (r + g + b) / 3;
                    if (luminance >= 128) {
                        const highlightFactor = 1 + (imageFilters.highlights / 100) * ((luminance - 128) / 127);
                        r *= highlightFactor;
                        g *= highlightFactor;
                        b *= highlightFactor;
                    }
                }

                // Invert
                if (imageFilters.invert) {
                    r = 255 - r;
                    g = 255 - g;
                    b = 255 - b;
                }

                data[i] = Math.max(0, Math.min(255, r));
                data[i + 1] = Math.max(0, Math.min(255, g));
                data[i + 2] = Math.max(0, Math.min(255, b));
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function downloadWordImage() {
            const previewCanvas = document.getElementById('wordPreview');
            if (previewCanvas.width === 0 || previewCanvas.width === 400) return;

            // Render a clean version without UI elements
            updateWordPreview(true);

            previewCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const cleanText = text.replace(/[^a-zA-Z0-9]/g, '_');
                a.download = `${cleanText}_word.png`;
                a.click();
                URL.revokeObjectURL(url);

                // Restore UI elements after download
                updateWordPreview(false);
            });
        }


        function setZoom(newZoom) {
            newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
            zoomLevel = newZoom;
            updateCanvasSize();
            updateZoomUI();
        }

        function zoomIn() {
            setZoom(zoomLevel + ZOOM_STEP);
        }

        function zoomOut() {
            setZoom(zoomLevel - ZOOM_STEP);
        }

        function resetZoom() {
            setZoom(1.0);
        }

        function fitZoom() {
            if (!image.complete) return;

            const canvasContainer = document.querySelector('.canvas-container');
            const containerRect = canvasContainer.getBoundingClientRect();

            // Calculate available space accounting for canvas-wrapper padding (100px on each side)
            const wrapperPadding = 200; // 100px left + 100px right (or top + bottom)
            const availableWidth = containerRect.width - wrapperPadding - 4; // wrapper padding + minimal padding
            const availableHeight = containerRect.height - wrapperPadding - 4; // wrapper padding + minimal padding

            // Calculate scale needed to fit image in container
            const widthScale = availableWidth / image.width;
            const heightScale = availableHeight / image.height;

            // Use the smaller scale to ensure image fits in both dimensions
            const fitScale = Math.min(widthScale, heightScale);

            // Convert to zoom level (fitScale is relative to original image, not baseScale)
            const newZoomLevel = fitScale / baseScale;

            setZoom(newZoomLevel);
        }

        // ==================== ROTATION FUNCTIONS ====================

        function extractRotatedCrop(sourceImage, x, y, width, height, rotation) {
            /**
             * Extract a crop from an image accounting for rotation.
             * The x, y, width, height are in the rotated coordinate space.
             * Returns a canvas with the extracted crop.
             */
            if (rotation === 0) {
                // No rotation - simple extraction
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(sourceImage, x, y, width, height, 0, 0, width, height);
                return canvas;
            }

            // Create a canvas for the rotated image
            const rotatedCanvas = document.createElement('canvas');
            const rotatedCtx = rotatedCanvas.getContext('2d');
            rotatedCanvas.width = sourceImage.width;
            rotatedCanvas.height = sourceImage.height;

            // Draw the rotated image
            rotatedCtx.save();
            rotatedCtx.translate(rotatedCanvas.width / 2, rotatedCanvas.height / 2);
            rotatedCtx.rotate(rotation * Math.PI / 180);
            rotatedCtx.translate(-rotatedCanvas.width / 2, -rotatedCanvas.height / 2);
            rotatedCtx.drawImage(sourceImage, 0, 0);
            rotatedCtx.restore();

            // Extract the crop from the rotated canvas
            const cropCanvas = document.createElement('canvas');
            const cropCtx = cropCanvas.getContext('2d');
            cropCanvas.width = width;
            cropCanvas.height = height;
            cropCtx.drawImage(rotatedCanvas, x, y, width, height, 0, 0, width, height);

            return cropCanvas;
        }

        function toggleRotationMode() {
            isRotationMode = !isRotationMode;
            const rotateBtn = document.getElementById('rotateBtn');

            if (isRotationMode) {
                rotateBtn.textContent = 'âœ“ Draw Line';
                rotateBtn.style.background = '#4CAF50';
                rotateBtn.style.color = 'white';
                canvas.style.cursor = 'crosshair';

                // Disable other modes
                isBaselineMode = false;
                isEditMode = false;
            } else {
                rotateBtn.textContent = 'â†» Rotate';
                rotateBtn.style.background = '';
                rotateBtn.style.color = '';
                canvas.style.cursor = 'crosshair';

                // Clear rotation line
                rotationLineStart = null;
                rotationLineEnd = null;
                redraw();
            }
        }

        function resetRotation() {
            imageRotation = 0;

            // Regenerate edited canvases for all boxes to remove rotation
            boxes.forEach(box => {
                if (box.editedCanvas) {
                    createEditedCanvas(box);
                }
            });

            updateRotationUI();
            updateWordPreview(); // Update preview with non-rotated crops
            redraw();
        }

        function applyRotation(angleDegrees) {
            imageRotation = angleDegrees;

            // Regenerate edited canvases for all boxes to account for new rotation
            boxes.forEach(box => {
                if (box.editedCanvas) {
                    createEditedCanvas(box);
                }
            });

            updateRotationUI();
            updateWordPreview(); // Update preview with rotated crops
            redraw();
        }

        function updateRotationUI() {
            const resetBtn = document.getElementById('resetRotationBtn');
            const rotationDisplay = document.getElementById('rotationDisplay');

            if (imageRotation !== 0) {
                resetBtn.style.display = 'inline-block';
                rotationDisplay.style.display = 'inline-block';
                rotationDisplay.textContent = `${imageRotation.toFixed(1)}Â°`;
            } else {
                resetBtn.style.display = 'none';
                rotationDisplay.style.display = 'none';
            }
        }

        function calculateRotationFromLine(x1, y1, x2, y2) {
            // Calculate angle of the line in degrees
            const dx = x2 - x1;
            const dy = y2 - y1;
            let angleDeg = Math.atan2(dy, dx) * (180 / Math.PI);

            // Determine if closer to horizontal (0/180) or vertical (90/270)
            // Normalize to -90 to 90 range
            while (angleDeg > 90) angleDeg -= 180;
            while (angleDeg < -90) angleDeg += 180;

            // Check if closer to horizontal or vertical
            const absAngle = Math.abs(angleDeg);

            if (absAngle <= 45) {
                // Closer to horizontal - rotate to make it perfectly horizontal (0Â°)
                return -angleDeg;
            } else {
                // Closer to vertical - rotate to make it perfectly vertical (90Â°)
                // If angle is positive (45-90), we need to rotate by -(angle - 90)
                // If angle is negative (-45 to -90), we need to rotate by -(angle + 90)
                if (angleDeg > 0) {
                    return -(angleDeg - 90);
                } else {
                    return -(angleDeg + 90);
                }
            }
        }

        function updateZoomUI() {
            const zoomDisplay = document.getElementById('zoomDisplay');
            if (zoomDisplay) {
                zoomDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
            }
        }

        function updateCanvasSize() {
            if (!image.complete) return;
            scale = baseScale * zoomLevel;

            // HiDPI support for annotation canvas
            const dpr = window.devicePixelRatio || 1;
            const logicalWidth = image.width * scale;
            const logicalHeight = image.height * scale;

            canvas.width = logicalWidth * dpr;
            canvas.height = logicalHeight * dpr;

            // Set CSS size to logical size
            canvas.style.width = logicalWidth + 'px';
            canvas.style.height = logicalHeight + 'px';

            // Scale context to account for DPR
            ctx.scale(dpr, dpr);

            updateCanvasContainerLayout();
            redraw();
        }

        function updateCanvasContainerLayout() {
            const canvasContainer = document.querySelector('.canvas-container');
            const containerRect = canvasContainer.getBoundingClientRect();

            // Only use flex centering if canvas fits in container
            const canvasFitsWidth = canvas.width <= containerRect.width;
            const canvasFitsHeight = canvas.height <= containerRect.height;

            if (canvasFitsWidth && canvasFitsHeight) {
                // Canvas is smaller - use flex centering
                canvasContainer.classList.add('center-canvas');
            } else {
                // Canvas is larger - remove flex centering to allow full scroll range
                canvasContainer.classList.remove('center-canvas');
            }
        }
    </script>
</body>
</html>
